##############################################################################
## Load pkg and script#
##############################################################################
## Load pkg and script#
library( methods )#
library( dplyr )#
library( openxlsx )#
library( RMySQL )#
library( data.table )#
library( lubridate )#
#
### XLSX Options#
hs1		<- createStyle(fgFill = "#DCE6F1", halign = "center", textDecoration = "Italic", border = "Bottom")#
#
hs2	<- createStyle(	#
		fgFill = "black", #
		fontSize = 12,#
		halign = "center", #
		textDecoration = "bold", #
			border = "Bottom")#
#
setValue 	<- function(name, colum, data, startRow = 2)#
{#
	addWorksheet( wb, name)#
	setColWidths(wb, sheet = name, cols = colum, widths = 22)#
	writeData(wb, sheet = name, data, startRow = startRow, headerStyle = hs1)#
}#
RowStat		<- function( data, id, #
					type = c('mean', 'var', 'sum','sd', 'min','max')) #
{				#
	type    <- match.arg( type )#
#
	FUN     <- switch( type,#
                mean = function(x) mean(x, na.rm = TRUE),#
                sum	 = function(x) sum(x, na.rm = TRUE),#
                var  = function(x) var(x, na.rm = TRUE),#
                sd   = function(x) sd(x, na.rm = TRUE),#
                min  = function(x) min(x, na.rm = TRUE),#
                max  = function(x) max(x, na.rm = TRUE)#
            )#
      Data		<- melt.data.table(data, id.vars = id)#
      Data1		<- Data[, FUN(value), by = id]#
      Data1		<- merge(data, Data1, by = id, all.x = TRUE)#
      setnames(Data1, "V1", "Total")#
      return(Data1)#
}#
tmpSum		<- function(x)#
{#
	if(is(x,'character') ||is(x, 'factor') ||is(x, 'Date'))#
	{#
		return(NA)#
	} else {#
		return(SUM(x))#
	}#
}#
#
#' x Fill in the title of legend#
Guide 	<- function(x, ...)#
{#
	x1 <- guides(	fill = guide_legend(#
					  title = x, #
					   title.position = "top", #
					 title.hjust = 0.5,#
					title.theme = element_text(size = 10, angle = 0),#
					keywidth 	= unit(15, "mm"), #
					keyheight	= unit(4,"mm"),#
					label.position = "bottom",#
					label.hjust 	= 0.5,#
					label.theme 	=  element_text(size = 9, angle = 0),#
								... #
					))#
	return(x1 )				#
}#
#' x Fill in the title of legend#
GuideCol 	<- function(x, ...)#
{#
	x1 <- guides(	colour = guide_legend(#
					  title = x, #
					   title.position = "top", #
					 title.hjust = 0.5,#
					title.theme = element_text(size = 10, angle = 0),#
					keywidth 	= unit(15, "mm"), #
					keyheight	= unit(4,"mm"),#
					label.position = "bottom",#
					label.hjust 	= 0.5,#
					label.theme 	=  element_text(size = 9, angle = 0),#
								... #
					))#
	return(x1 )				#
}#
#
"pathSet"			<- function( x )#
{#
	if( is( x, "character"))#
	{#
		cmd				<- paste0("echo ", x)#
		cmd1			<-  pipe( cmd , open = "r")#
		path			<-   scan(cmd1, what = "character")  #
		close(cmd1)#
		return(path)#
	} else {#
	 	stop("Input is ", class( x ), " and not valid in")#
	}	#
}#
char_to_num		<- function(x) as.numeric(as.character(x))#
#' USAGE: Con  <- fileCon$new( name = <filePath>, content = <character[|Vector]> )#
#' 		Con$openCon()  will open connection and write <content> param to <name>#
#'    	Con$testCon() will test if there is any connection#
#' TODO: 	update testCon() to suppress warning message, #
#'			Build openCon() to handel read or write and reading content into #
#'			data.table object #
#' Returns: File to destionation in name#
fileCon <- setRefClass("fileCon", #
				fields = list( 	name 	= "character",#
								content = "character" ),#
				methods = list(#
					testCon	=  function ( n = name)#
					{#
						Test 	<- try(isOpen( name ), silent = TRUE)#
						if( inherits(Test, 'try-error') )#
						{#
							return(FALSE)#
						} else {#
							return( TRUE )	#
						}#
					},#
					openCon	= function( )#
					{#
						if(! testCon( ) )#
						{#
							con	<- file	(description = name, open = "w", encoding = "UTF8")#
							writeLines(content, con = con )#
							close( con )#
							message(basename(name), " done and closed connection")#
						}	#
					}	#
				)#
)#
#' x the table name#
#' USAGE getData( x = "Invoice")#
getData		<- function( x, query = NULL, dbname = "kriita_db1" )#
{#
	con			<- try( dbConnect(MySQL(),	user = 'serdara', 	password = 'aiiR1eX5d', #
 							host = '193.182.121.238', dbname = dbname, port = 3306),#
 							silent = TRUE)#
 	if( ! inherits(con, "try-error") )#
	{						#
		if(is.null(query))#
		{#
			Query	<- sprintf("SELECT * FROM %s", x)#
		} else {#
			Query <- query#
		}	#
		res		<- dbSendQuery(con, statement = Query)#
		data1	<- data.table( dbFetch(res, n = -1) )#
	}	#
	dbClearResult(res)#
	dbDisconnect(con)#
	return( data1 )#
}#
#' USAGE: Object <- new("startUps", pkgs = .PACK, Input = c("data", "graf") )#
#' CALL: Object$instant_pkgs( ), will update and install pkgs #
#' CALL: Object$setDirs( Extra ), will create and set path #
#'		to <Input> and if nessecary to the <Extra> character#
startUps <- setRefClass("startUps",#
			fields 	= list( pkgs = "character", Input = "character", path = "character" ),#
			methods	= list(#
				instant_pkgs = function( )#
				{#
					pkgs_miss <- pkgs[which(!pkgs %in% installed.packages()[, 1])]#
    				if (length(pkgs_miss) > 0)#
    				{#
        				install.packages(pkgs_miss)#
    				}#
    				if (length( pkgs_miss) == 0)#
    				{#
        				message("\n ...Packages were already installed!\n")#
    				}#
   	     			attached <- search()#
    				attached_pkgs <- attached[grepl("package", attached)]#
    				need_to_attach <- pkgs[which(!pkgs %in% gsub("package:", "", attached_pkgs))]#
    				if (length(need_to_attach) > 0)#
    				{#
        				for (i in 1:length(need_to_attach))#
							require(need_to_attach[i], character.only = TRUE)#
   	}#
					if (length(need_to_attach) == 0)#
					{#
        				message("\n ...Packages were already loaded!\n")#
					}#
#
				}, # End of function  #
				setDirs		= function( )#
				{#
					if( length(Input) > 0)#
					{#
						.HOME	<- path#
						Input	<<- c(Input)#
						if( inherits(Input, "character") )#
						{#
							Output	<- paste0(toupper(Input), " <- file.path('", .HOME, "','", Input, "')")#
							for( d in Output)#
							{#
								cat("************************************************\n")#
								String	<- gsub(".*\'(.*)\'.*", "\\1", toupper(d))#
								cat("Path for", String , "completed\n")#
								Step1 	<- parse(text = d)#
								cat("************************************************\n")#
								assign(String , eval(Step1), globalenv() ) #
								!file.exists(get( String )) && dir.create( get(String) ,#
											 recursive = TRUE)#
							} # ForLoop ends here#
						} else {#
							stop("Need to input character inside ", deparse(substitute(Input)))#
						}#
					}	#
					}	 ## End of function setDirs#
			) # End of methodsList	#
) # End of setRefClass#
Format <- function( x, n, by = 0, ... ) {#
    Fun <- function( x, n,...) {#
        Char 	<- prettyNum(	round(x, digits = by ), big.mark = " ",#
                             nsmall = 0,scientific = FALSE,...)#
        if( missing( n ) ){#
            n <- nchar(Char)#
            }#
        R  <- sprintf( paste("%.", n, "s", sep = "") ,Char)#
        return(R)#
    }#
    if( length( x ) > 1 ) {#
        List <- sapply(x, Fun)#
        return( List )#
        } else {#
            return( Fun( x , n,... ) )#
            }#
    }#
 # USAGE: Will split data|vector into distinct breaks#
 # with the <by> options, use ... inside cut#
 "Segment" <- function(x, by = 0.15 , ...) {#
 	S		<- seq(0,1, by )#
 	quantile <- cut(x, breaks = quantile(x, probs = S, na.rm = TRUE), ..., #
        						include.lowest = TRUE, labels =  names(S))#
    return ( quantile ) #
}   #
pal <- function(col, border = "light gray", ...){#
    n <- length(col)#
    plot(0,0, type = "n", xlim = c(0,1), ylim = c(0,1),#
    axes = FALSE,  xlab = "", ylab = "", ...)#
    rect(0:(n-1)/n,0, 1:n/n, 1, col = col, border = border)#
}#
#
#' tableFun( data, columCol , fontFace)#
#' columCol is only for header and defautl is white text #
#' fontFace is the 1) Plain, 2) bold, 3) italic, 4) both italic and bold#
tableFun	<- function( data, columCol = "azure3", plot = FALSE, fontFace = 3)#
{#
	tt3		<- ttheme_minimal(#
		core=list(	bg_params = list(fill='white', col=NA),#
					fg_params = list(fontface = fontFace)),#
		colhead=list(bg_params = list(fill= columCol, col=NA),#
					fg_params = list(fontface = 2, col = "white"))			#
	)#
	step1		<- tableGrob(data, rows = NULL, theme = tt3)#
	separators 	<- replicate(ncol(step1) - 1,#
						segmentsGrob(x1 = unit(0, "npc")),#
						simplify = FALSE)#
	step1	<- gtable::gtable_add_grob( step1, grobs = separators,#
							t = 1, b = nrow(step1), l = seq_len(ncol(step1) - 1) + 1)#
	if( plot ) {#
		grid.draw( step1 )#
	} else {#
		return( step1 )#
	}								#
}#
SUM		<- function(x) sum(x, na.rm = TRUE)#
MEAN		<- function(x) mean(x, na.rm = TRUE)#
LENGTH	<- function(x) length(x, na.rm =TRUE)#
#
###########################################################################################
# Color options and font #
###########################################################################################
col_blue		 		<- rgb( 0, 68, 91, maxColorValue = 255 )#
col_blueGreen			<- rgb( 89, 155, 161, maxColorValue=255 )#
col_green				<- rgb( 44, 171, 102, maxColorValue=255 )#
col_red 				<- rgb( 237, 47, 36, maxColorValue=255 )#
col_grey		 		<- rgb( 76, 76, 76, maxColorValue=255 )#
col_orange		 		<- rgb( 242, 101, 34, maxColorValue=255 )#
col_yellow				<- rgb( 251, 173, 29, maxColorValue=255 )#
col_neut 				<- rgb( 229, 229, 229, maxColorValue=255 )#
col_purple				<- rgb( 147, 112, 229, maxColorValue=255)#
col_gold				<- rgb(184, 134, 11, maxColorValue=255 )#
col_khaki				<- rgb(189, 183, 107,  maxColorValue=255)#
colPro			<- c(	"col_blue" = col_blue, "col_blueGreen" = col_blueGreen,#
					"col_green" = col_green, "col_red" = col_red,#
					"col_orange" = col_orange, "col_khaki" = col_khaki,#
					"col_yellow" = col_yellow, "col_purple" = col_purple,#
					"col_gold" = col_gold,"col_grey" = col_grey )#
Company	<- list( 'UK' = c(	"comeon","bertil", "vinnarum", #
							"casinoroom","redkings","svenskalottoportalen",#
							"3hholdings","garantispelet","videoslots",#
							"europaspelet","garantispelet","supervinsten",#
							"superspelet") )					#
## Load in common table #
Query 	<- sprintf("SELECT * FROM ExchangeRate WHERE #
					date = ( SELECT max(date) FROM ExchangeRate)")#
#
Rates 	<- getData(query = Query)#
## Change to swedish currency #
Rates[, Rates := Rates[currency == 'SEK', rate]/rate]#
Rates		<- Rates[,.(Currency = currency, Rates)]#
## This is by each transaction#
StartDate		<- "2014-10-01"#
CurrentDate		<- Sys.Date( )#
LastDay			<- CurrentDate - days(2)#
LastDate		<- CurrentDate - months(1)
Query				<- "SELECT ss.operatorId, #
								ss.type, #
								ss.siteId, #
								ocs.country#
					  	FROM Site ss #
					  	INNER JOIN OperatorCountrySettings ocs ON ( ss.operatorId = ocs.operatorId)"#
Meacode					<- getData(query = Query)
Meacode
Query				<- "SELECT ss.operatorId, #
								ss.type, #
								ss.siteId, #
								ocs.country#
					  	FROM Site ss #
					  	INNER JOIN OperatorCountrySettings ocs ON ( ss.operatorId = ocs.operatorId)#
					  	INNER JOIN MerchantCountrySettings mcs ON ( mcs.merchantId = ss.siteId)"#
Meacode					<- getData(query = Query)
Meacode
Query				<- "SELECT ss.operatorId, #
								ss.type, #
								ss.siteId, #
								ocs.country#
					  	FROM Site ss #
					  	INNER JOIN OperatorCountrySettings ocs ON ( ss.operatorId = ocs.operatorId)#
					  	INNER JOIN MerchantCountrySettings mcs ON ( mcs.merchantId = ss.siteId AND mcs.country =  ocs.country)"#
Meacode					<- getData(query = Query)
Meacode
Query				<- "SELECT ss.operatorId, #
								ss.type, #
								ss.siteId, #
								ocs.country,#
								 COALESCE(mcs.invoiceHoldPeriod  ,ocs.invoiceHoldPeriod ) AS invoiceHoldPeriod#
					  	FROM Site ss #
					  	INNER JOIN OperatorCountrySettings ocs ON ( ss.operatorId = ocs.operatorId)#
					  	INNER JOIN MerchantCountrySettings mcs ON ( mcs.merchantId = ss.siteId AND mcs.country =  ocs.country)"#
Meacode					<- getData(query = Query)
Meacode
Query					<- "SELECT 	mm.merchantId, #
									mm.country,#
									ss.type AS TYPE, #
									ss.operatorId,#
									mcs.invoiceHoldPeriod,#
									IFNULL(mcs.invoiceHoldPeriodRecurring, mm.invoiceHoldPeriodRecurring) AS invoiceHoldPeriodRecurring#
									mcs.invoicableStatuses FROM MeacodeMerchant mm #
						INNER JOIN Site ss ON (mm.merchantId = ss.siteId)#
						INNER JOIN MerchantCountrySettings mcs ON (mm.merchantId = mcs.merchantId AND #
																	mm.country = mcs.country)"
Meacode					<- getData(query = Query)
Query					<- "SELECT 	mm.merchantId, #
									mm.country,#
									ss.type AS TYPE, #
									ss.operatorId,#
									mcs.invoiceHoldPeriod,#
									IFNULL(mcs.invoiceHoldPeriodRecurring, mm.invoiceHoldPeriodRecurring) AS invoiceHoldPeriodRecurring,#
									mcs.invoicableStatuses FROM MeacodeMerchant mm #
						INNER JOIN Site ss ON (mm.merchantId = ss.siteId)#
						INNER JOIN MerchantCountrySettings mcs ON (mm.merchantId = mcs.merchantId AND #
																	mm.country = mcs.country)"
Meacode					<- getData(query = Query)
Query					<- "SELECT 	mm.merchantId, #
									mm.country,#
									ss.type AS TYPE, #
									ss.operatorId,#
									mcs.invoiceHoldPeriod,#
									IFNULL(mcs.invoiceHoldPeriodRecurring, mm.invoiceHoldPeriodRecurring) AS invoiceHoldPeriodRecurring,#
									mcs.invoicableStatuses #
							FROM MeacodeMerchant mm #
						INNER JOIN Site ss ON (mm.merchantId = ss.siteId)#
						INNER JOIN MerchantCountrySettings mcs ON (mm.merchantId = mcs.merchantId AND #
																	mm.country = mcs.country)"#
#
Meacode					<- getData(query = Query)
Query					<- "SELECT 	mm.merchantId, #
									mm.country,#
									ss.type AS TYPE, #
									ss.operatorId,#
									mcs.invoiceHoldPeriod,#
									COALESCE(mcs.invoiceHoldPeriodRecurring, mm.invoiceHoldPeriodRecurring) AS invoiceHoldPeriodRecurring,#
									mcs.invoicableStatuses #
							FROM MeacodeMerchant mm #
						INNER JOIN Site ss ON (mm.merchantId = ss.siteId)#
						INNER JOIN MerchantCountrySettings mcs ON (mm.merchantId = mcs.merchantId AND #
																	mm.country = mcs.country)"#
#
Meacode					<- getData(query = Query)
Query					<- "SELECT 	mm.merchantId, #
									mm.country,#
									ss.type AS TYPE, #
									ss.operatorId,#
									mcs.invoiceHoldPeriod,#
									mcs.invoicableStatuses #
							FROM MeacodeMerchant mm #
						INNER JOIN Site ss ON (mm.merchantId = ss.siteId)#
						INNER JOIN MerchantCountrySettings mcs ON (mm.merchantId = mcs.merchantId AND #
																	mm.country = mcs.country)"#
#
Meacode					<- getData(query = Query)
Query					<- "SELECT 	mm.merchantId, #
									mm.country,#
									ss.type AS TYPE, #
									ss.operatorId,#
									IFNULL(mcs.invoiceHoldPeriod, mm.invoiceHoldPeriod) AS invoiceHoldPeriod,#
									mcs.invoicableStatuses #
							FROM MeacodeMerchant mm #
						INNER JOIN Site ss ON (mm.merchantId = ss.siteId)#
						INNER JOIN MerchantCountrySettings mcs ON (mm.merchantId = mcs.merchantId AND #
																	mm.country = mcs.country)"#
#
Meacode					<- getData(query = Query)
Meacode
Meacode[operatorId == 'nordiskaspel']
Query					<- "SELECT 	mm.merchantId, #
									mm.country,#
									ss.type AS TYPE, #
									ss.operatorId,#
									COALESCE(mcs.invoiceHoldPeriod, mm.invoiceHoldPeriod) AS invoiceHoldPeriod,#
									mcs.invoicableStatuses #
							FROM MeacodeMerchant mm #
						INNER JOIN Site ss ON (mm.merchantId = ss.siteId)#
						INNER JOIN MerchantCountrySettings mcs ON (mm.merchantId = mcs.merchantId AND #
																	mm.country = mcs.country)"#
#
Meacode					<- getData(query = Query)
Meacode[operatorId == 'nordiskaspel']
Query					<- "SELECT 	mm.merchantId, #
									mm.country,#
									ss.type AS TYPE, #
									ss.operatorId,#
									COALESCE(mcs.invoiceHoldPeriod, mm.invoiceHoldPeriod) AS invoiceHoldPeriod,#
									 COALESCE(mcs.invoiceHoldPeriodRecurring  , mm.invoiceHoldPeriodRecurring ) AS invoiceHoldPeriodRecurring#
									mcs.invoicableStatuses #
							FROM MeacodeMerchant mm #
						INNER JOIN Site ss ON (mm.merchantId = ss.siteId)#
						INNER JOIN MerchantCountrySettings mcs ON (mm.merchantId = mcs.merchantId AND #
																	mm.country = mcs.country)"#
#
Meacode					<- getData(query = Query)
Query					<- "SELECT 	mm.merchantId, #
									mm.country,#
									ss.type AS TYPE, #
									ss.operatorId,#
									COALESCE(mcs.invoiceHoldPeriod, mm.invoiceHoldPeriod) AS invoiceHoldPeriod,#
									COALESCE(mcs.invoiceHoldPeriodRecurring, mm.invoiceHoldPeriodRecurring) AS invoiceHoldPeriodRecurring,#
									mcs.invoicableStatuses #
							FROM MeacodeMerchant mm #
						INNER JOIN Site ss ON (mm.merchantId = ss.siteId)#
						INNER JOIN MerchantCountrySettings mcs ON (mm.merchantId = mcs.merchantId AND #
																	mm.country = mcs.country)"#
#
Meacode					<- getData(query = Query)
Query					<- "SELECT 	mm.merchantId, #
									mm.country,#
									ss.type AS TYPE, #
									ss.operatorId,#
									COALESCE(mcs.invoiceHoldPeriod, mm.invoiceHoldPeriod) AS invoiceHoldPeriod,#
									mcs.invoiceHoldPeriodRecurring,#
									mcs.invoicableStatuses #
							FROM MeacodeMerchant mm #
						INNER JOIN Site ss ON (mm.merchantId = ss.siteId)#
						INNER JOIN MerchantCountrySettings mcs ON (mm.merchantId = mcs.merchantId AND #
																	mm.country = mcs.country)"#
#
Meacode					<- getData(query = Query)
Query					<- "SELECT 	mm.merchantId, #
									mm.country,#
									ss.type AS TYPE, #
									ss.operatorId,#
									COALESCE(mcs.invoiceHoldPeriod, mm.invoiceHoldPeriod) AS invoiceHoldPeriod,#
									COALESCE(mcs.invoiceHoldPeriodRecurring, mm.invoiceHoldPeriodRecurring) AS invoiceHoldPeriodRecurring,#
									mcs.invoicableStatuses #
							FROM MeacodeMerchant mm #
						INNER JOIN Site ss ON (mm.merchantId = ss.siteId)#
						INNER JOIN MerchantCountrySettings mcs ON (mm.merchantId = mcs.merchantId AND #
																	mm.country = mcs.country)"#
#
Meacode					<- getData(query = Query)
Meacode[operatorId == 'nordiskaspel']
Query					<- "SELECT 	mm.merchantId, #
									mm.country,#
									mm.invoiceFee,#
									mm.invoiceFeeVatRate,#
									mm.invoiceLateInterestPercentage,#
									mm.invoiceDeliveryEmail,#
									mm.invoiceDeliveryPaper,#
									mm.invoiceDeliverySms,#
									mm.invoiceDeliveryReminderEmail,#
									mm.invoiceDeliveryReminderPaper,#
									mm.invoiceDeliveryReminderSms, #
									ss.type AS TYPE, #
									ss.operatorId,#
									COALESCE(mcs.invoiceHoldPeriod, mm.invoiceHoldPeriod) AS invoiceHoldPeriod,#
									mm.collectionDelay,#
									mm.invoicePaymentTerms,#
									mm.reminderDelay, #
									mcs.invoiceHoldPeriodRecurring,#
									mcs.invoicableStatuses #
							FROM MeacodeMerchant mm #
						INNER JOIN Site ss ON (mm.merchantId = ss.siteId)#
						INNER JOIN MerchantCountrySettings mcs ON (mm.merchantId = mcs.merchantId AND #
																	mm.country = mcs.country)"#
#
Meacode					<- getData(query = Query)
Meacode
Meacode[operatorId == 'nordiskaspel']
Meacode[, TYPE := ifelse(grepl("RISK", TYPE), 'NoRisk', #
						ifelse(grepl("NORMAL", TYPE), "Risk", TYPE) )]
Meacode[grepl("Risk", TYPE), Risk := 1]			#
Meacode[grepl("NoRisk", TYPE), Risk := 0]#
#
Meacode[grepl("store" , storeId), operatorId := 'Store']
Meacode
Meacode[grepl("stor", merchantId)]
##############################################################################
## Load pkg and script#
##############################################################################
## Load pkg and script#
library( methods )#
library( dplyr )#
library( openxlsx )#
library( RMySQL )#
library( data.table )#
library( lubridate )#
#
### XLSX Options#
hs1		<- createStyle(fgFill = "#DCE6F1", halign = "center", textDecoration = "Italic", border = "Bottom")#
#
hs2	<- createStyle(	#
		fgFill = "black", #
		fontSize = 12,#
		halign = "center", #
		textDecoration = "bold", #
			border = "Bottom")#
#
setValue 	<- function(name, colum, data, startRow = 2)#
{#
	addWorksheet( wb, name)#
	setColWidths(wb, sheet = name, cols = colum, widths = 22)#
	writeData(wb, sheet = name, data, startRow = startRow, headerStyle = hs1)#
}#
RowStat		<- function( data, id, #
					type = c('mean', 'var', 'sum','sd', 'min','max')) #
{				#
	type    <- match.arg( type )#
#
	FUN     <- switch( type,#
                mean = function(x) mean(x, na.rm = TRUE),#
                sum	 = function(x) sum(x, na.rm = TRUE),#
                var  = function(x) var(x, na.rm = TRUE),#
                sd   = function(x) sd(x, na.rm = TRUE),#
                min  = function(x) min(x, na.rm = TRUE),#
                max  = function(x) max(x, na.rm = TRUE)#
            )#
      Data		<- melt.data.table(data, id.vars = id)#
      Data1		<- Data[, FUN(value), by = id]#
      Data1		<- merge(data, Data1, by = id, all.x = TRUE)#
      setnames(Data1, "V1", "Total")#
      return(Data1)#
}#
tmpSum		<- function(x)#
{#
	if(is(x,'character') ||is(x, 'factor') ||is(x, 'Date'))#
	{#
		return(NA)#
	} else {#
		return(SUM(x))#
	}#
}#
#
#' x Fill in the title of legend#
Guide 	<- function(x, ...)#
{#
	x1 <- guides(	fill = guide_legend(#
					  title = x, #
					   title.position = "top", #
					 title.hjust = 0.5,#
					title.theme = element_text(size = 10, angle = 0),#
					keywidth 	= unit(15, "mm"), #
					keyheight	= unit(4,"mm"),#
					label.position = "bottom",#
					label.hjust 	= 0.5,#
					label.theme 	=  element_text(size = 9, angle = 0),#
								... #
					))#
	return(x1 )				#
}#
#' x Fill in the title of legend#
GuideCol 	<- function(x, ...)#
{#
	x1 <- guides(	colour = guide_legend(#
					  title = x, #
					   title.position = "top", #
					 title.hjust = 0.5,#
					title.theme = element_text(size = 10, angle = 0),#
					keywidth 	= unit(15, "mm"), #
					keyheight	= unit(4,"mm"),#
					label.position = "bottom",#
					label.hjust 	= 0.5,#
					label.theme 	=  element_text(size = 9, angle = 0),#
								... #
					))#
	return(x1 )				#
}#
#
"pathSet"			<- function( x )#
{#
	if( is( x, "character"))#
	{#
		cmd				<- paste0("echo ", x)#
		cmd1			<-  pipe( cmd , open = "r")#
		path			<-   scan(cmd1, what = "character")  #
		close(cmd1)#
		return(path)#
	} else {#
	 	stop("Input is ", class( x ), " and not valid in")#
	}	#
}#
char_to_num		<- function(x) as.numeric(as.character(x))#
#' USAGE: Con  <- fileCon$new( name = <filePath>, content = <character[|Vector]> )#
#' 		Con$openCon()  will open connection and write <content> param to <name>#
#'    	Con$testCon() will test if there is any connection#
#' TODO: 	update testCon() to suppress warning message, #
#'			Build openCon() to handel read or write and reading content into #
#'			data.table object #
#' Returns: File to destionation in name#
fileCon <- setRefClass("fileCon", #
				fields = list( 	name 	= "character",#
								content = "character" ),#
				methods = list(#
					testCon	=  function ( n = name)#
					{#
						Test 	<- try(isOpen( name ), silent = TRUE)#
						if( inherits(Test, 'try-error') )#
						{#
							return(FALSE)#
						} else {#
							return( TRUE )	#
						}#
					},#
					openCon	= function( )#
					{#
						if(! testCon( ) )#
						{#
							con	<- file	(description = name, open = "w", encoding = "UTF8")#
							writeLines(content, con = con )#
							close( con )#
							message(basename(name), " done and closed connection")#
						}	#
					}	#
				)#
)#
#' x the table name#
#' USAGE getData( x = "Invoice")#
getData		<- function( x, query = NULL, dbname = "kriita_db1" )#
{#
	con			<- try( dbConnect(MySQL(),	user = 'serdara', 	password = 'aiiR1eX5d', #
 							host = '193.182.121.238', dbname = dbname, port = 3306),#
 							silent = TRUE)#
 	if( ! inherits(con, "try-error") )#
	{						#
		if(is.null(query))#
		{#
			Query	<- sprintf("SELECT * FROM %s", x)#
		} else {#
			Query <- query#
		}	#
		res		<- dbSendQuery(con, statement = Query)#
		data1	<- data.table( dbFetch(res, n = -1) )#
	}	#
	dbClearResult(res)#
	dbDisconnect(con)#
	return( data1 )#
}#
#' USAGE: Object <- new("startUps", pkgs = .PACK, Input = c("data", "graf") )#
#' CALL: Object$instant_pkgs( ), will update and install pkgs #
#' CALL: Object$setDirs( Extra ), will create and set path #
#'		to <Input> and if nessecary to the <Extra> character#
startUps <- setRefClass("startUps",#
			fields 	= list( pkgs = "character", Input = "character", path = "character" ),#
			methods	= list(#
				instant_pkgs = function( )#
				{#
					pkgs_miss <- pkgs[which(!pkgs %in% installed.packages()[, 1])]#
    				if (length(pkgs_miss) > 0)#
    				{#
        				install.packages(pkgs_miss)#
    				}#
    				if (length( pkgs_miss) == 0)#
    				{#
        				message("\n ...Packages were already installed!\n")#
    				}#
   	     			attached <- search()#
    				attached_pkgs <- attached[grepl("package", attached)]#
    				need_to_attach <- pkgs[which(!pkgs %in% gsub("package:", "", attached_pkgs))]#
    				if (length(need_to_attach) > 0)#
    				{#
        				for (i in 1:length(need_to_attach))#
							require(need_to_attach[i], character.only = TRUE)#
   	}#
					if (length(need_to_attach) == 0)#
					{#
        				message("\n ...Packages were already loaded!\n")#
					}#
#
				}, # End of function  #
				setDirs		= function( )#
				{#
					if( length(Input) > 0)#
					{#
						.HOME	<- path#
						Input	<<- c(Input)#
						if( inherits(Input, "character") )#
						{#
							Output	<- paste0(toupper(Input), " <- file.path('", .HOME, "','", Input, "')")#
							for( d in Output)#
							{#
								cat("************************************************\n")#
								String	<- gsub(".*\'(.*)\'.*", "\\1", toupper(d))#
								cat("Path for", String , "completed\n")#
								Step1 	<- parse(text = d)#
								cat("************************************************\n")#
								assign(String , eval(Step1), globalenv() ) #
								!file.exists(get( String )) && dir.create( get(String) ,#
											 recursive = TRUE)#
							} # ForLoop ends here#
						} else {#
							stop("Need to input character inside ", deparse(substitute(Input)))#
						}#
					}	#
					}	 ## End of function setDirs#
			) # End of methodsList	#
) # End of setRefClass#
Format <- function( x, n, by = 0, ... ) {#
    Fun <- function( x, n,...) {#
        Char 	<- prettyNum(	round(x, digits = by ), big.mark = " ",#
                             nsmall = 0,scientific = FALSE,...)#
        if( missing( n ) ){#
            n <- nchar(Char)#
            }#
        R  <- sprintf( paste("%.", n, "s", sep = "") ,Char)#
        return(R)#
    }#
    if( length( x ) > 1 ) {#
        List <- sapply(x, Fun)#
        return( List )#
        } else {#
            return( Fun( x , n,... ) )#
            }#
    }#
 # USAGE: Will split data|vector into distinct breaks#
 # with the <by> options, use ... inside cut#
 "Segment" <- function(x, by = 0.15 , ...) {#
 	S		<- seq(0,1, by )#
 	quantile <- cut(x, breaks = quantile(x, probs = S, na.rm = TRUE), ..., #
        						include.lowest = TRUE, labels =  names(S))#
    return ( quantile ) #
}   #
pal <- function(col, border = "light gray", ...){#
    n <- length(col)#
    plot(0,0, type = "n", xlim = c(0,1), ylim = c(0,1),#
    axes = FALSE,  xlab = "", ylab = "", ...)#
    rect(0:(n-1)/n,0, 1:n/n, 1, col = col, border = border)#
}#
#
#' tableFun( data, columCol , fontFace)#
#' columCol is only for header and defautl is white text #
#' fontFace is the 1) Plain, 2) bold, 3) italic, 4) both italic and bold#
tableFun	<- function( data, columCol = "azure3", plot = FALSE, fontFace = 3)#
{#
	tt3		<- ttheme_minimal(#
		core=list(	bg_params = list(fill='white', col=NA),#
					fg_params = list(fontface = fontFace)),#
		colhead=list(bg_params = list(fill= columCol, col=NA),#
					fg_params = list(fontface = 2, col = "white"))			#
	)#
	step1		<- tableGrob(data, rows = NULL, theme = tt3)#
	separators 	<- replicate(ncol(step1) - 1,#
						segmentsGrob(x1 = unit(0, "npc")),#
						simplify = FALSE)#
	step1	<- gtable::gtable_add_grob( step1, grobs = separators,#
							t = 1, b = nrow(step1), l = seq_len(ncol(step1) - 1) + 1)#
	if( plot ) {#
		grid.draw( step1 )#
	} else {#
		return( step1 )#
	}								#
}#
SUM		<- function(x) sum(x, na.rm = TRUE)#
MEAN		<- function(x) mean(x, na.rm = TRUE)#
LENGTH	<- function(x) length(x, na.rm =TRUE)#
#
###########################################################################################
# Color options and font #
###########################################################################################
col_blue		 		<- rgb( 0, 68, 91, maxColorValue = 255 )#
col_blueGreen			<- rgb( 89, 155, 161, maxColorValue=255 )#
col_green				<- rgb( 44, 171, 102, maxColorValue=255 )#
col_red 				<- rgb( 237, 47, 36, maxColorValue=255 )#
col_grey		 		<- rgb( 76, 76, 76, maxColorValue=255 )#
col_orange		 		<- rgb( 242, 101, 34, maxColorValue=255 )#
col_yellow				<- rgb( 251, 173, 29, maxColorValue=255 )#
col_neut 				<- rgb( 229, 229, 229, maxColorValue=255 )#
col_purple				<- rgb( 147, 112, 229, maxColorValue=255)#
col_gold				<- rgb(184, 134, 11, maxColorValue=255 )#
col_khaki				<- rgb(189, 183, 107,  maxColorValue=255)#
colPro			<- c(	"col_blue" = col_blue, "col_blueGreen" = col_blueGreen,#
					"col_green" = col_green, "col_red" = col_red,#
					"col_orange" = col_orange, "col_khaki" = col_khaki,#
					"col_yellow" = col_yellow, "col_purple" = col_purple,#
					"col_gold" = col_gold,"col_grey" = col_grey )#
Company	<- list( 'UK' = c(	"comeon","bertil", "vinnarum", #
							"casinoroom","redkings","svenskalottoportalen",#
							"3hholdings","garantispelet","videoslots",#
							"europaspelet","garantispelet","supervinsten",#
							"superspelet") )					#
## Load in common table #
Query 	<- sprintf("SELECT * FROM ExchangeRate WHERE #
					date = ( SELECT max(date) FROM ExchangeRate)")#
#
Rates 	<- getData(query = Query)#
## Change to swedish currency #
Rates[, Rates := Rates[currency == 'SEK', rate]/rate]#
Rates		<- Rates[,.(Currency = currency, Rates)]#
## This is by each transaction#
StartDate		<- "2014-10-01"#
CurrentDate		<- Sys.Date( )#
LastDay			<- CurrentDate - days(2)#
LastDate		<- CurrentDate - months(1)#
Query					<- "SELECT 	mm.merchantId, #
									mm.country,#
									mm.invoiceFee,#
									mm.storeId, #
									mm.invoiceFeeVatRate,#
									mm.invoiceLateInterestPercentage,#
									mm.invoiceDeliveryEmail,#
									mm.invoiceDeliveryPaper,#
									mm.invoiceDeliverySms,#
									mm.invoiceDeliveryReminderEmail,#
									mm.invoiceDeliveryReminderPaper,#
									mm.invoiceDeliveryReminderSms, #
									ss.type AS TYPE, #
									ss.operatorId,#
									COALESCE(mcs.invoiceHoldPeriod, mm.invoiceHoldPeriod) AS invoiceHoldPeriod,#
									mm.collectionDelay,#
									mm.invoicePaymentTerms,#
									mm.reminderDelay, #
									mcs.invoiceHoldPeriodRecurring,#
									mcs.invoicableStatuses #
							FROM MeacodeMerchant mm #
						INNER JOIN Site ss ON (mm.merchantId = ss.siteId)#
						INNER JOIN MerchantCountrySettings mcs ON (mm.merchantId = mcs.merchantId AND #
																	mm.country = mcs.country)"#
#
Meacode					<- getData(query = Query)#
#
## rm så that it will be unique sites, can be multiple settlementCurrency #
Meacode[, TYPE := ifelse(grepl("RISK", TYPE), 'NoRisk', #
						ifelse(grepl("NORMAL", TYPE), "Risk", TYPE) )]#
Meacode[grepl("Risk", TYPE), Risk := 1]			#
Meacode[grepl("NoRisk", TYPE), Risk := 0]#
#
Meacode[grepl("store" , storeId), operatorId := 'Store']#
#
query							<- "SELECT * FROM Person"#
Person							<- getData(query = query)#
deductionRule	<- list('COMPENSATION' 				= 'co',#
  						'PAPER_INVOICE_CHARGE'  	= 'pc',#
  						'FALLBACK_DEL_CHARGE'		= 'fb',#
  						'COMPENSATION_INTEREST'		= 'ci',#
  						'COMPENSATION_REMINDER' 	= 'cr',#
  	 					'INVOICING_CHARGE'	 	    = 'cf',#
  						'CANCELLATION'          	= 'cl',#
						'MANUAL' 					= 'ma')#
settlmentRules 	<- list( 	'cl' = 'cancelled',#
							'da' = 'AfterSettlementPeriod',#
							'dp' = 'AfterSettlementPeriodWhenPaid',#
							'ia' = 'Immediately' ,#
							'ip' = 'ImmediatelyWhenPaid'#
)
#!/usr/bin/env Rscript #
###########################################################################################
# This script is used for all sort of task that aren't to be for #
# reporting purposes, just for solvning different task#
###########################################################################################
options(scipen = 999)#
options("openxlsx.dateFormat" = "yyyy-mm-dd")#
#
Sys.setenv("R_ZIPCMD" = "/usr/bin/zip") ## makes openxlsx works in centos#
#
scoreScale		<- c('MycketHög' = "c(70,100)",	'Hög' = "c(40, 69)", "Medel" = "c(20,39)", "Låg" = "c(1,19)")#
scoreNum 		<- list('1' = c("intervall" = "c(70,100)", 'time' = 120 ),#
						'2' = c("intervall" = "c(40, 69)", 'time' = 120 ),#
						'3' = c("intervall" = "c(20, 39)", 'time' = 60 ),#
						'4' = c("intervall" = "c(1, 19)", 'time' = 60 )#
)#
library(methods)	#
#
"pathSet"			<- function( x )#
{#
	if( is( x, "character"))#
	{#
		cmd				<- paste0("echo ", x)#
		cmd1			<- pipe( cmd , open = "r")#
		path			<- scan(cmd1, what = "character")  #
		close(cmd1)#
		return(path)#
	} else {#
	 	stop("Input is ", class( x ), " and not valid in")#
	}	#
}#
FULLPATH		<- pathSet( x = "$PWD" )#
.HOME			<- dirname(FULLPATH)#
# Set the home diretory #
DIR				<- basename(FULLPATH)#
# All R-files #
RFiles 					<- list.files(path = '.' , include.dirs = TRUE, pattern = "*.R$", #
											recursive = TRUE, full.names = TRUE)#
# Load common functions and files , also Meocode and Person table is loaded#
source(file = grep("commonfunction", RFiles,  value = TRUE, perl = TRUE, ignore.case = TRUE) )#
DATA					<- file.path(FULLPATH, "Data")#
LOG						<- file.path(FULLPATH, "logs")#
if(! file.exists(DATA) )#
{ ## If missing dir#
	dir.create(DATA, recursive = TRUE)#
}#
#
## Set Meacode according to specification rules #
.operatorId		<- 'nordiskaspel'#
Meacode			<- Meacode[grepl( .operatorId , operatorId)]#
#
Regexp			<- paste0(Meacode[, unique(merchantId)], collapse = "|")#
## Further pkg loaded#
Packages			 	<- c('reshape2', 'reshape', 'ggthemes', #
							'RColorBrewer','scales', 'ggplot2',  'grid',#
							'gridExtra',"Hmisc", "jsonlite")#
## Set path and load pkgs#
Pack		<- new("startUps", pkgs = Packages, path = dirname(FULLPATH) )#
Pack$instant_pkgs()#
## Get the lastest rates from ExchangeRate #
Pack$setDirs( )#
CurrentDate		<- Sys.Date( )#
args1			<- ifelse( length( commandArgs(TRUE)) > 0, commandArgs(TRUE), "invoice")#
args1			<- tolower(args1)#
.operatorId		<- 'nordiskaspel'#
#####################################################################################
## Load data for Nordiska#
#####################################################################################
Query 	<- sprintf("SELECT 	ei.*,#
							iv.personId,#
							iv.siteId,#
							iv.ocrNumber,#
							iv.ocrNumberReminder,#
							iv.dueDate,#
							iv.playerId,#
							ss.type,#
							ss.operatorId, #
							iv.state,#
							IF( ei.playingCurrency = 'EUR' #
									AND ei.invoiceCurrency = 'SEK', #
										ei.originalSettlementFee*ei.conversionRate, #
											ei.originalSettlementFee) AS TransactionFee#
							FROM ErpInvoice ei #
						INNER JOIN Invoice iv ON (ei.invoiceNumber = iv.invoiceNumber)#
						INNER JOIN Site ss ON (iv.siteId = ss.siteId)#
						WHERE ss.operatorId RLIKE  '%s'",  .operatorId	)#
#
Step1 				<- getData(query = Query )#
Query 				<- sprintf("SELECT eph.* ,#
										ss.type,#
										ss.operatorId#
								FROM ErpPaymentHistory eph #
								INNER JOIN Invoice ei ON (eph.invoiceNumber = ei.invoiceNumber)#
								INNER JOIN Site ss ON (ei.siteId = ss.siteId)#
									WHERE ss.operatorId RLIKE  '%s'", .operatorId	 )#
Step2 				<- getData(query = Query )#
## Estimate the realmoney and get the last date #
moneyDT					<-   Step2[grepl('(m|r)',type) , .(money = SUM(amount), moneyDate =  paymentDate[.N]), by = .(invoiceNumber)]#
#
Step1 					<- merge(Step1, moneyDT, by = 'invoiceNumber', all.x = TRUE)#
Step1[is.na(money), money := 0]#
rm(moneyDT)#
compensationDT			<-  Step2[grepl('c|e|p', type), .(compensation = SUM(amount), compensationDate = paymentDate[.N]), by = .(invoiceNumber)]#
#
Step1 				<- merge(Step1, compensationDT, by = 'invoiceNumber', all.x = TRUE)#
Step1[is.na(compensation), compensation := 0]#
#
rm(compensationDT)#
#
ErpInvoice			<- copy(Step1)#
ErpInvoice[order(createdAt), Count := 1:.N, by = .(personId)]#
rm(Step2, Step1)#
gc(reset = TRUE)#
#
Query 				<- sprintf("SELECT eph.* ,#
										ss.type,#
										ss.operatorId#
								FROM ErpPaymentHistory eph #
								INNER JOIN Invoice ei ON (eph.invoiceNumber = ei.invoiceNumber)#
								INNER JOIN Site ss ON (ei.siteId = ss.siteId)#
									WHERE ss.operatorId RLIKE  '%s'", .operatorId	 )#
Query		<- sprintf("SELECT et.* FROM ErpTransaction et #
							INNER JOIN Invoice ei ON (et.invoiceNumber = ei.invoiceNumber)#
							INNER JOIN Site ss ON (ei.siteId = ss.siteId)#
								WHERE ss.operatorId RLIKE  '%s'", .operatorId	 )#
#
Step1 				<- getData(query = Query )#
idx					<- unique(Step1[,  transactionId])#
query 							<- 'SELECT * FROM SettlementDeduction'#
SettlementDeduction				<- getData(query = query)#
setnames(SettlementDeduction, 'amount', 'DeductedAmount')#
setkey(SettlementDeduction, transactionId)#
SettlementDeduction 			<- SettlementDeduction[J(idx)][!is.na(DeductedAmount)]#
SettlementDeduction[order(paidAt), Count := 1:.N, by = .(transactionId)]#
SettlementDeduction[, ':=' ( DeductedAmount = DeductedAmount*-1 ,#
							type = ifelse(is.na(type), '', type)#
)]#
SettlementDeduction[, tmp := paste0(DeductedAmount, ' ', type)]#
SettlementDeduction1		<-  dcast.data.table(SettlementDeduction, transactionId ~ Count, value.var = 'tmp')#
Names						<- colnames(SettlementDeduction1)#
Names						<- setdiff(Names,'transactionId')#
Names1						<- paste0('Nr_',Names)#
setnames(SettlementDeduction1, 2:NCOL(SettlementDeduction1), Names1)#
#
Step1					<- merge(Step1, SettlementDeduction1, by = 'transactionId', all.x = TRUE)#
rm(SettlementDeduction1, SettlementDeduction, Names, Names1)#
ErpTransaction			<- copy(Step1)#
#
rm(Step1)#
gc(reset = TRUE)#
Query				<- sprintf("SELECT * FROM InvoiceStateLog");#
#
InvoiceStateLog 	<- getData(query = Query )#
#
Query				<- sprintf("SELECT sc.*, #
										ss.type, #
										ss.operatorId FROM Subscription sc#
								INNER JOIN Site ss ON(ss.siteId = sc.merchantId)#
								WHERE ss.operatorId  RLIKE '%s'", .operatorId	 );#
#
Subscription 				<- getData(query = Query )#
Query				<- sprintf("SELECT sc.merchantId,#
								 sl.* FROM SubscriptionLog sl#
								INNER JOIN Subscription sc ON (sl.subscriptionId = sc.subscriptionId)#
								INNER JOIN Site ss ON(ss.siteId = sc.merchantId)#
								WHERE ss.operatorId  RLIKE '%s'", .operatorId);#
#
SubscriptionLog 	 <- getData(query = Query )#
Query				<- sprintf("SELECT rr.*,#
								 		 ss.type, #
										ss.operatorId FROM Reservation rr#
								INNER JOIN Site ss ON(rr.merchantId = ss.siteId)#
								WHERE ss.operatorId RLIKE '%s'", .operatorId );#
Reservation			<- getData(query = Query)#
#
Query				<- sprintf("SELECT tt.* ,#
										ss.type, #
										ss.operatorId FROM Transaction tt#
								INNER JOIN Site ss ON(tt.siteId = ss.siteId)#
								WHERE ss.operatorId RLIKE '%s'", .operatorId );#
Transaction			<- getData(query = Query)
idx					<- ErpInvoice[, unique(personId)]#
	setkey(Person, personId)#
	PersonDT			<- Person[J(idx)][,.( personId, country, email, phone, ssn, street, zip, city)]
stopifnot(exists('.operatorId') && exists('PersonDT') )
library(RCurl)#
library(XML)#
		con				<- try( dbConnect(MySQL(),	user = 'serdara', 	password = 'aiiR1eX5d', #
 										host = '193.182.121.238', dbname = "kriita_survey", port = 3306),#
 										silent = TRUE)	  #
		Query				<- "SELECT * FROM kriita_survey.PaylevoCreditCheck"									#
		creditData			<- getData(query = Query)		#
dbDisconnect(con)	#
setkey(PersonDT, personId)#
setkey(creditData, personId)#
idx						<- PersonDT[, unique(personId)]	#
creditDataDT			<- creditData[J(idx), ][!is.na(checkDate)]	#
rm(creditData)		#
idx1					<- creditDataDT[, unique(personId)]	#
idx2					<- idx[!idx %in% idx1]		#
missingPerson			<- PersonDT[J(idx2)]
###############################################################################
# Funtion used for getting the persons#
##############################################################################			#
closeConnections 		<- function( )#
{#
	allCons 	<- 	dbListConnections(MySQL())#
	for( cons in allCons) dbDisconnect(cons)#
	con	 <- try( dbConnect(MySQL(),	user = 'serdara', 	password = 'aiiR1eX5d', #
 									host = '193.182.121.238', dbname = "kriita_survey", port = 3306),#
 									silent = TRUE)#
 	tmp	<- dbGetQuery(con, "show processlist")#
 	setDT(tmp)#
 	tmp1			<- tmp[db == 'kriita_survey' & ! grepl("processlist", Info)]#
 	if( NROW(tmp1) > 100) {#
 		for( i in 30:NROW(tmp1))#
 		{#
 			cat("\n==", i, "\n")#
 			Kill			<- paste0("KILL ", tmp1[i, Id])#
 			dbGetQuery(con, Kill)#
 		}#
 	} else {#
 		return()#
 	} #
 	dbDisconnect(con)#
}			#
#' arg {string} Takes the filename given by  internal:requestBody() and check the content#
		#' returns {list} status and dataset content #
		#' USAGE dataSet	<- readXML(filename)#
		#' getcontents 		dataSet$status#
readCredit			<- function(files, type = 'JSON', country = 'SE')#
{ #
		if( regexpr('XML', type, ignore.case = TRUE ) > 0 )#
		{#
			step1 	<- tryCatch({ #
						 	xmlParse(files, useInternal = TRUE, asText = TRUE)#
						},#
						error = function(e){#
				 			htmlParse(files, useInternal = TRUE, asText = TRUE)#
			})#
			Data			<- xmlToList(step1)	#
			Data1			<- unlist(Data)	#
			LowerNames		<- names(Data1)#
			LowerNames1 	<- unlist( #
								lapply(  strsplit(LowerNames, "\\."), function( x ) paste0( x[(length(x) - 1):length(x) ], collapse = '.')) )#
			names(Data1)	<- 	LowerNames1#
		} else {#
			Data 			<- fromJSON( files )#
			Data1			<- unlist(Data)#
			LowerNames		<- names(Data1)#
			LowerNames1 	<- unlist( #
								lapply(  strsplit(LowerNames, "\\."), function( x ) paste0( x[(length(x) - 1):length(x) ], collapse = '.')) )#
			names(Data1)	<- 	LowerNames1#
		} ## end of regexpr.XML #
		DataDT			<- data.table(keys = names(Data1), values = as.character(Data1))#
 		#rmRegexp		<- '\\b(GIVEN_NAME|PNR|FIRST_NAME|LAST_NAME|socialSecurityNumber|consumerName|KysyttyHenkiloTunnus|Lahiosoite|KieliR)'#
		#DataDT 			<- DataDT[!grepl(rmRegexp, keys, ignore.case = TRUE)]#
		DataDT[, ':=' ( keys 	= toupper(keys),#
						values 	= as.character(values)) ]	#
		dataJSON	<- jsonlite::toJSON(DataDT)#
		if(exists('dataJSON') && ( NROW(DataDT) > 30 | country == 'FI') )#
		{#
					return(dataJSON)#
		} else {#
					return('ERROR')#
		}#
} ## end of func #
#10624#
#42883#
arg = missingPerson[personId == '90689', .(personId, ssn, country)]#
#getCreditData ()#
### Make so that adress lookup is not present#
#' USAGE getCreditData(PersonDT[personId == '1217'])#
#' should be a data.table #
getCreditData		<- function( arg )#
{#
		con	 <- try( dbConnect(MySQL(),	user = 'serdara', 	password = 'aiiR1eX5d', #
 										host = '193.182.121.238', dbname = "kriita_survey", port = 3306),#
 										silent = TRUE)	#
 		if(inherits(con, 'try-error'))#
 		{#
 			closeConnections()#
 			con	 <- try( dbConnect(MySQL(),	user = 'serdara', 	password = 'aiiR1eX5d', #
 										host = '193.182.121.238', dbname = "kriita_survey", port = 3306),#
 										silent = TRUE)	#
 		}							#
		stopifnot(is.data.table( arg )) #
		persId					<- arg[, personId] ## used to insert into table#
		Names					<- colnames(arg[, .(ssn, country)])#
		Values					<- as.character(arg[, .(ssn, country)])#
		if(any(is.na(Values))) return('ERROR') #
		country					<- as.character(arg[, country])#
		Step1					<-  paste0( '"', Names, '":', '"', Values, '"', collapse = ",")#
		Step2 					<- paste0('"customer"' , ": {", Step1, "}")#
		Step3					<- paste0("{", Step2, "}")#
		messages				<- cat("Running personId", persId)#
		print(messages)#
		cat(messages)#
		rm(messages)#
		rm(Step1, Step2, Names, Values)#
		headerFields <- c(Accept = "application/json", Authorization = 'v3FwMdcfRwv0KYet',#
    						'Content-Type' = "application/json;charset=UTF-8")#
		URL1	<- "https://api.kriita.com/lookup/v2/search/ssn"	#
		req 	<- 	tryCatch({#
							httpPOST(	url 		= URL1,#
										.encoding 	= 'UTF-8',						 	#
											.opts 	= list( ssl.verifypeer = TRUE, connecttimeout = 30, sslversion = 3),#
									followlocation 	= TRUE,#
									httpheader 		= headerFields,#
									postfields 		= print(quote = FALSE, Step3),	#
									maxredirs 		= 5 ) #
					},	error = function(cond){#
						print('ERROR')#
					})#
		if(! regexpr("ERROR", req, ignore.case = TRUE) > 0 )#
		{#
			data1		<- jsonlite::fromJSON(req)	#
			status		<- data1$status					#
			tmp			<- data.frame( data1$payload )#
			if(NROW(tmp) == 0 || nchar(tmp[, 'sourceData'])  < 10 )#
			{#
				logFile			<- file.path(LOG, sprintf("insertPerson_%s.txt", Sys.Date()))#
				file.exists("logFile") || file.create(logFile)#
				cat("*************\n")#
				cat("Nothing to output", "\n")#
				cat("*************\n")#
				cat(persId, file = logFile, sep = "\n", append = TRUE)#
				return('ERROR source data')	#
			}#
			payload		<- subset( tmp, select = c(sourceData, source, createdAt))#
			rm(tmp); gc(reset = TRUE)#
			setDT(payload)	#
			### Loop through all the elements in payload#
			Nrows		<- NROW(payload)	 	#
			for( rowInt in seq_len(Nrows) )#
			{#
				sourceDT			<- payload[rowInt,]#
				setDT(sourceDT)#
				sourceData			<- sourceDT[, sourceData]#
				sourceType 			<- ifelse( regexpr('(\\b(xml)\\b|<.*>)', sourceData, ignore.case = TRUE) > 0, 'XML', 'JSON' )#
				source1				<- sourceDT[, source]#
				time1				<- gsub("(.*)\\..*", "\\1", sourceDT[, createdAt])#
				time2				<- as.POSIXlt(gsub("T", " ", time1))#
				sourceTime			<- format(time2 , format = '%Y-%m-%d')#
				PersonQ				<- sprintf("SELECT COUNT(*) FROM kriita_survey.PaylevoCreditCheck WHERE personId = '%s' AND checkDate = '%s'", persId, sourceTime )	#
				tmpRes			<- dbSendQuery(con, statement = PersonQ)#
				tmpDT			<- as.integer(as.character( dbFetch(tmpRes, n = -1) ))#
				if( tmpDT > 0) next #
				parseDT 			<- switch(sourceData, #
												S2		= 'Protected',#
												S3		= 'Spärrad' , #
												S4		= 'Avliden', #
												S5		= 'Tekniks avregistrerad', #
												S6		= 'Utvandrad', #
												S7		='Personnummer byte',#
											readCredit(sourceData, type = sourceType, country = country)#
										)#
			if(  regexpr('ERROR', parseDT) > 0  )#
			{#
				errorFile			<- file.path(LOG, sprintf("errorData_%s.txt", Sys.Date()))#
				file.exists("errorFile") || file.create(errorFile)#
				cat("*************\n")#
				cat("Nothing to output", "\n")#
				cat("*************\n")#
				cat(persId, file = errorFile, sep = "\n", append = TRUE)#
				return(NA)	#
				rm(parseDT, sourceData, sourceDT)#
			} ## end of regexp.Error#
			insertQuery		<- sprintf("INSERT INTO PaylevoCreditCheck( `personId`, `country`, `checkDate`, `sourceType`, `sourceData` ) #
											VALUES('%s','%s', '%s', '%s', '%s')",  persId , country, sourceTime , source1 , parseDT )		#
			insertQuery 	<- gsub("[\t\n\t]", "", insertQuery)#
			res				<-  try( dbSendQuery(con, statement =  insertQuery), silent = TRUE)		#
			if(inherits(res, 'try-error'))#
			{#
				closeConnections( )#
				con	 <- try( dbConnect(MySQL(),	user = 'serdara', 	password = 'aiiR1eX5d', #
 										host = '193.182.121.238', dbname = "kriita_survey", port = 3306),#
 										silent = TRUE)#
				try(dbSendQuery(con, statement = insertQuery), silent = TRUE)	#
				dbDisconnect(con)#
			} ## end of if.inherits#
		} ## end of forLoop.rowInt#
	} ## end of reg.expr #
	dbDisconnect(con)#
} ## end of function
library(doSNOW)
library(doParallel)
## Function for loading pkg for parallel enviornment#
worker.init		<- function( pkg ){#
	for( p in pkg ){#
		library( p, character.only = TRUE)#
	}#
	NULL#
}
Tid <- system.time({#
	cores 	<- getOption("mc.cores", detectCores())#
	cl		<- makeCluster( cores ) #
	clusterCall( cl, worker.init,  c('RCurl', 'XML', 'RMySQL', 'data.table', 'jsonlite'))#
	## Används för lägga in webExtrac och data in i environmnet#
	clusterExport(cl, c("getCreditData","readCredit", "missingPerson","getData", "closeConnections", "LOG"), envir = environment())#
	parLapply(cl, 1:NROW( missingPerson ), #
		function( x ) getCreditData(missingPerson[x]) )#
	stopCluster(cl)#
})[1:3]
if( NROW( missingPerson) > 0)#
{ #
   library(doSNOW)#
library(doParallel)#
## Function for loading pkg for parallel enviornment#
worker.init		<- function( pkg ){#
	for( p in pkg ){#
		library( p, character.only = TRUE)#
	}#
	NULL#
}#
Tid <- system.time({#
	cores 	<- getOption("mc.cores", detectCores())#
	cl		<- makeCluster( cores ) #
	clusterCall( cl, worker.init,  c('RCurl', 'XML', 'RMySQL', 'data.table', 'jsonlite'))#
	## Används för lägga in webExtrac och data in i environmnet#
	clusterExport(cl, c("getCreditData","readCredit", "missingPerson","getData", "closeConnections", "LOG"), envir = environment())#
	parLapply(cl, 1:NROW( missingPerson ), #
		function( x ) getCreditData(missingPerson[x]) )#
	stopCluster(cl)#
})[1:3]#
	cat( "Time ", Tid)			#
}
for( i in 1:NROW( missingPerson ))#
{#
	cat("Running i personId ", missingPerson[i, personId] , "\n" )#
	getCreditData(missingPerson[i]) #
}
errorFile			<- file.path(LOG, sprintf("errorData_%s.txt", Sys.Date()))
errorFile
file.exists("errorFile") || file.create(errorFile)
file.exists("errorFile")
file.exists(errorFile)
errorFile
getwd()
#!/usr/bin/env Rscript #
###########################################################################################
# This script is used for all sort of task that aren't to be for #
# reporting purposes, just for solvning different task#
###########################################################################################
options(scipen = 999)#
options("openxlsx.dateFormat" = "yyyy-mm-dd")#
#
Sys.setenv("R_ZIPCMD" = "/usr/bin/zip") ## makes openxlsx works in centos#
#
scoreScale		<- c('MycketHög' = "c(70,100)",	'Hög' = "c(40, 69)", "Medel" = "c(20,39)", "Låg" = "c(1,19)")#
scoreNum 		<- list('1' = c("intervall" = "c(70,100)", 'time' = 120 ),#
						'2' = c("intervall" = "c(40, 69)", 'time' = 120 ),#
						'3' = c("intervall" = "c(20, 39)", 'time' = 60 ),#
						'4' = c("intervall" = "c(1, 19)", 'time' = 60 )#
)#
library(methods)	#
#
"pathSet"			<- function( x )#
{#
	if( is( x, "character"))#
	{#
		cmd				<- paste0("echo ", x)#
		cmd1			<- pipe( cmd , open = "r")#
		path			<- scan(cmd1, what = "character")  #
		close(cmd1)#
		return(path)#
	} else {#
	 	stop("Input is ", class( x ), " and not valid in")#
	}	#
}#
FULLPATH		<- pathSet( x = "$PWD" )#
.HOME			<- dirname(FULLPATH)#
# Set the home diretory #
DIR				<- basename(FULLPATH)#
# All R-files #
RFiles 					<- list.files(path = '.' , include.dirs = TRUE, pattern = "*.R$", #
											recursive = TRUE, full.names = TRUE)#
# Load common functions and files , also Meocode and Person table is loaded#
source(file = grep("commonfunction", RFiles,  value = TRUE, perl = TRUE, ignore.case = TRUE) )#
DATA					<- file.path(FULLPATH, "Data")#
LOG						<- file.path(FULLPATH, "logs")#
GRAF					<- file.path(FULLPATH, "GRAF")
c(DATA, LOG, GRAF)
for( dd in c(DATA, LOG, GRAF))#
{#
	if(! file.exists(dd) )#
	{ ## If missing dir#
		dir.create(dd, recursive = TRUE)#
	}#
}
## Further pkg loaded#
Packages			 	<- c('reshape2', 'reshape', 'ggthemes', #
							'RColorBrewer','scales', 'ggplot2',  'grid',#
							'gridExtra',"Hmisc", "jsonlite")#
## Set path and load pkgs#
Pack		<- new("startUps", pkgs = Packages, path = dirname(FULLPATH) )#
Pack$instant_pkgs()#
## Get the lastest rates from ExchangeRate #
Pack$setDirs( )#
CurrentDate		<- Sys.Date( )#
args1			<- ifelse( length( commandArgs(TRUE)) > 0, commandArgs(TRUE), "invoice")#
args1			<- tolower(args1)#
.operatorId		<- 'nordiskaspel'#
#
## Set Meacode according to specification rules #
#
Meacode			<- Meacode[grepl( .operatorId , operatorId)]#
#
Regexp			<- paste0(Meacode[, unique(merchantId)], collapse = "|")
Meacode
Query 	<- sprintf("SELECT 	ei.*,#
							iv.personId,#
							iv.siteId,#
							iv.ocrNumber,#
							iv.ocrNumberReminder,#
							iv.dueDate,#
							iv.playerId,#
							ss.type,#
							ss.operatorId, #
							iv.state,#
							IF( ei.playingCurrency = 'EUR' #
									AND ei.invoiceCurrency = 'SEK', #
										ei.originalSettlementFee*ei.conversionRate, #
											ei.originalSettlementFee) AS TransactionFee#
							FROM ErpInvoice ei #
						INNER JOIN Invoice iv ON (ei.invoiceNumber = iv.invoiceNumber)#
						INNER JOIN Site ss ON (iv.siteId = ss.siteId)#
						WHERE ss.operatorId RLIKE  '%s'",  .operatorId	)#
#
Step1 				<- getData(query = Query )#
Query 				<- sprintf("SELECT eph.* ,#
										ss.type,#
										ss.operatorId#
								FROM ErpPaymentHistory eph #
								INNER JOIN Invoice ei ON (eph.invoiceNumber = ei.invoiceNumber)#
								INNER JOIN Site ss ON (ei.siteId = ss.siteId)#
									WHERE ss.operatorId RLIKE  '%s'", .operatorId	 )#
Step2 				<- getData(query = Query )#
## Estimate the realmoney and get the last date #
moneyDT					<-   Step2[grepl('(m|r)',type) , .(money = SUM(amount), moneyDate =  paymentDate[.N]), by = .(invoiceNumber)]#
#
Step1 					<- merge(Step1, moneyDT, by = 'invoiceNumber', all.x = TRUE)#
Step1[is.na(money), money := 0]#
rm(moneyDT)#
compensationDT			<-  Step2[grepl('c|e|p', type), .(compensation = SUM(amount), compensationDate = paymentDate[.N]), by = .(invoiceNumber)]#
#
Step1 				<- merge(Step1, compensationDT, by = 'invoiceNumber', all.x = TRUE)#
Step1[is.na(compensation), compensation := 0]#
#
rm(compensationDT)#
#
ErpInvoice			<- copy(Step1)#
ErpInvoice[order(createdAt), Count := 1:.N, by = .(personId)]#
rm(Step2, Step1)#
gc(reset = TRUE)#
#
Query 				<- sprintf("SELECT eph.* ,#
										ss.type,#
										ss.operatorId#
								FROM ErpPaymentHistory eph #
								INNER JOIN Invoice ei ON (eph.invoiceNumber = ei.invoiceNumber)#
								INNER JOIN Site ss ON (ei.siteId = ss.siteId)#
									WHERE ss.operatorId RLIKE  '%s'", .operatorId	 )#
Query		<- sprintf("SELECT et.* FROM ErpTransaction et #
							INNER JOIN Invoice ei ON (et.invoiceNumber = ei.invoiceNumber)#
							INNER JOIN Site ss ON (ei.siteId = ss.siteId)#
								WHERE ss.operatorId RLIKE  '%s'", .operatorId	 )#
#
Step1 				<- getData(query = Query )#
idx					<- unique(Step1[,  transactionId])#
query 							<- 'SELECT * FROM SettlementDeduction'#
SettlementDeduction				<- getData(query = query)#
setnames(SettlementDeduction, 'amount', 'DeductedAmount')#
setkey(SettlementDeduction, transactionId)#
SettlementDeduction 			<- SettlementDeduction[J(idx)][!is.na(DeductedAmount)]#
SettlementDeduction[order(paidAt), Count := 1:.N, by = .(transactionId)]#
SettlementDeduction[, ':=' ( DeductedAmount = DeductedAmount*-1 ,#
							type = ifelse(is.na(type), '', type)#
)]#
SettlementDeduction[, tmp := paste0(DeductedAmount, ' ', type)]#
SettlementDeduction1		<-  dcast.data.table(SettlementDeduction, transactionId ~ Count, value.var = 'tmp')#
Names						<- colnames(SettlementDeduction1)#
Names						<- setdiff(Names,'transactionId')#
Names1						<- paste0('Nr_',Names)#
setnames(SettlementDeduction1, 2:NCOL(SettlementDeduction1), Names1)#
#
Step1					<- merge(Step1, SettlementDeduction1, by = 'transactionId', all.x = TRUE)#
rm(SettlementDeduction1, SettlementDeduction, Names, Names1)#
ErpTransaction			<- copy(Step1)#
#
rm(Step1)#
gc(reset = TRUE)#
Query				<- sprintf("SELECT * FROM InvoiceStateLog");#
#
InvoiceStateLog 	<- getData(query = Query )#
#
Query				<- sprintf("SELECT sc.*, #
										ss.type, #
										ss.operatorId FROM Subscription sc#
								INNER JOIN Site ss ON(ss.siteId = sc.merchantId)#
								WHERE ss.operatorId  RLIKE '%s'", .operatorId	 );#
#
Subscription 				<- getData(query = Query )#
Query				<- sprintf("SELECT sc.merchantId,#
								 sl.* FROM SubscriptionLog sl#
								INNER JOIN Subscription sc ON (sl.subscriptionId = sc.subscriptionId)#
								INNER JOIN Site ss ON(ss.siteId = sc.merchantId)#
								WHERE ss.operatorId  RLIKE '%s'", .operatorId);#
#
SubscriptionLog 	 <- getData(query = Query )#
Query				<- sprintf("SELECT rr.*,#
								 		 ss.type, #
										ss.operatorId FROM Reservation rr#
								INNER JOIN Site ss ON(rr.merchantId = ss.siteId)#
								WHERE ss.operatorId RLIKE '%s'", .operatorId );#
Reservation			<- getData(query = Query)#
#
Query				<- sprintf("SELECT *  FROM Transaction")#
Transaction			<- getData(query = Query)#
Transaction			<- merge(Transaction, Reservation[, .(invoiceNumber ,reservationId, merchantId, type, operatorId)], by = 'reservationId', all.x = TRUE)#
#
Player 				<- getData(query = "SELECT * FROM Player")
ErpInvoice 				<- merge(ErpInvoice, Transaction[!is.na(invoiceNumber), .(invoiceNumber,  merchantItemId, amountPerItem)], by = 'invoiceNumber', all.x = TRUE)#
ErpInvoice 				<- ErpInvoice[!is.na(invoiceNumber)]#
#
ErpTransaction			<- merge(ErpTransaction, ErpInvoice[,.( invoiceNumber, siteId, operatorId, playerId)], #
								by = 'invoiceNumber', all.x = TRUE)
R.version
#!/usr/bin/env Rscript #
###########################################################################################
# Use for inserting person into table for credit data for api function#
###########################################################################################
library(XML)#
library(jsonlite)#
options(error = function() traceback(2))#
RFiles 					<- list.files(path = '.' , include.dirs = TRUE, pattern = "*.R$", #
											recursive = TRUE, full.names = TRUE)#
# Load common functions and files , also Meocode and Person table is loaded#
source(file = grep("commonfunction", RFiles,  value = TRUE, perl = TRUE, ignore.case = TRUE) )#
worker.init		<- function( pkg ){#
			for( p in pkg ){#
				library( p, character.only = TRUE)#
			}#
			NULL#
		}#
insertPersonDB		<- function(ids, country, checkDate, sourceT,  sourceData )#
{#
		date			<- ifelse(missing(checkDate), Sys.Date(), checkDate)#
		country			<- ifelse(missing(country), 'SE', country)#
		sourceT			<- ifelse(missing(sourceT), 'CREDITCHECK', sourceT)#
		if(missing(sourceData) || missing(ids)) stop("Script is stopped, missing source")#
		if( !  exists('con'))#
		{#
				con	 <- try( dbConnect(MySQL(),	user = 'serdara', 	password = 'aiiR1eX5d', #
 										host = '193.182.121.238', dbname = "kriita_survey", port = 3306),#
 										silent = TRUE)	#
 				if(inherits(con, 'try-error'))#
 				{#
 					closeConnections()#
 					con	 <- try( dbConnect(MySQL(),	user = 'serdara', 	password = 'aiiR1eX5d', #
 										host = '193.182.121.238', dbname = "kriita_survey", port = 3306),#
 										silent = TRUE)	#
 				}	#
 		}									#
		insertQuery		<- sprintf("INSERT INTO PaylevoCreditCheck( `personId`, `country`, `checkDate`, `sourceType`, `sourceData` ) #
											VALUES('%s','%s', '%s', '%s', '%s')",  ids , country, date , sourceT , sourceData )		#
		insertQuery 	<- gsub("[\t\n\t]", "", insertQuery)#
		res				<-  dbSendQuery(con, statement =  insertQuery)	#
		cat("###############Sucess###############", "\n")#
		dbClearResult(res)#
}		#
readXML			<- function(x)#
{#
#
	xml_1			<- x[, xmlParse( sourceData)]#
	.ssn			<- x[, trimws(ssn)]#
	.person			<- x[, trimws(personId)]#
	.country		<- x[, trimws(country)]#
	.checkdate		<- x[, trimws(checkDate)]#
	.sourcetype		<- x[, trimws(type)]#
	cat("\nPersonId : ", .person	 , "\n")#
	xml_2  			<- getNodeSet(xml_1, "//GETDATA_RESPONSE")[[1]]#
	xml_3 			<- xmlSApply(xml_2, xmlValue)#
	if(	length(xml_3) < 10 )#
	{#
		return( message("no values inside xml: ssn ", 	.ssn) )#
	}#
	dataDT 			<- data.table(keys	= names(xml_3), values = xml_3)#
	rmKeys			<- '(PNR|FIRST_NAME|GIVEN_NAME|LAST_NAME|CO_ADDRESS|REGISTERED_ADDRESS|ADDRESS|ZIPCODE|TOWN|COMMUNITY|FORSAMLING|FORSAMLINGNO|VAT)'#
	dataDT1			<-  dataDT[!keys %like% rmKeys, ]#
	dataDT1[values == '',  values := NA]#
	dataDT1[, ':=' ( keys 	= toupper(keys),#
						values 	= as.character(values)) ]	#
	sourceData		<-	jsonlite::toJSON( dataDT1)#
	insertPersonDB(ids = .person, country = .country, checkDate = .checkdate, sourceT = .sourcetype, sourceData = sourceData)#
	cat("************* DONE***************")	#
}		#
###############################################################################
# Funtion used for getting the persons#
##############################################################################			#
closeConnections 		<- function( )#
{#
	allCons 	<- 	dbListConnections(MySQL())#
	for( cons in allCons) dbDisconnect(cons)#
	con	 <- try( dbConnect(MySQL(),	user = 'serdara', 	password = 'aiiR1eX5d', #
 									host = '193.182.121.238', dbname = "kriita_survey", port = 3306),#
 									silent = TRUE)#
 	tmp	<- dbGetQuery(con, "show processlist")#
 	setDT(tmp)#
 	tmp1			<- tmp[db == 'kriita_survey' & ! grepl("processlist", Info)]#
 	if( NROW(tmp1) > 100) {#
 		for( i in 30:NROW(tmp1))#
 		{#
 			cat("\n==", i, "\n")#
 			Kill			<- paste0("KILL ", tmp1[i, Id])#
 			dbGetQuery(con, Kill)#
 		}#
 	} else {#
 		return()#
 	} #
 	dbDisconnect(con)#
}			#
######################################################################################################
# Load data #
######################################################################################################
Query 	<- sprintf("SELECT 	ei.*,#
							iv.personId,#
							iv.siteId,#
							iv.ocrNumber,#
							iv.ocrNumberReminder,#
							iv.dueDate,#
							iv.playerId,#
							ss.type,#
							ss.operatorId, #
							iv.state,#
							IF( ei.playingCurrency = 'EUR' #
									AND ei.invoiceCurrency = 'SEK', #
										ei.originalSettlementFee*ei.conversionRate, #
											ei.originalSettlementFee) AS TransactionFee#
							FROM ErpInvoice ei #
						INNER JOIN Invoice iv ON (ei.invoiceNumber = iv.invoiceNumber)#
						INNER JOIN Site ss ON (iv.siteId = ss.siteId)")#
ErpInvoice 				<- getData(query = Query )#
ErpInvoice[order(createdAt), Count := 1:.N, by = .(personId)]#
Query				<- "SELECT * FROM SsnLookupLog WHERE type = 'CREDITCHECK' AND source = 'CREDITSAFE'"#
SsnLookupLog 		<- getData(query = Query)#
SsnLookupLog 		<- merge(SsnLookupLog , Person[, .(ssn, personId)], by = 'ssn', all.x = TRUE)#
SsnLookupLog[, checkDate := as.character(as.Date(createdAt))]#
PaylevoCreditCheck	<- getData(query = "select * from kriita_survey.PaylevoCreditCheck where sourceType = 'CREDITSAFE'")#
PaylevoCreditCheck[ , .N, by = .(personId, checkDate)][ N > 1]#
PaylevoCreditCheck[personId == '44050']#
selectionDT			<- merge(	PaylevoCreditCheck[, .(checkDate, personId)], #
								SsnLookupLog[, .( checkDate, personId)], by = c('checkDate', 'personId'), all.x = TRUE) #
idx					<- unique(selectionDT$personId)#
idx1				<- ErpInvoice[grepl("Delta", collectionParty), unique(personId) ]#
setkey(SsnLookupLog, personId)
PaylevoCreditCheck[personId == '44050']
PaylevoCreditCheck
PaylevoCreditCheck[ordinal == '48393']
PaylevoCreditCheck	<- getData(query = "select * from kriita_survey.PaylevoCreditCheck where personId = '44050'")
PaylevoCreditCheck
PaylevoCreditCheck	<- getData(query = "select * from kriita_survey.PaylevoCreditCheck where sourceType = 'CREDITCHECK'")
PaylevoCreditCheck[ , .N, by = .(personId, checkDate)][ N > 1]
PaylevoCreditCheck
unique(PaylevoCreditCheck[, .(ordinal, checkDate, personId)], by = 'personId')
unique(PaylevoCreditCheck[, .(ordinal, checkDate, personId)], by = 'personId', fromLast = TRUE)
tmp		<- unique(PaylevoCreditCheck[, .(ordinal, checkDate, personId)], by = 'personId', fromLast = TRUE)
con	 <- try( dbConnect(MySQL(),	user = 'serdara', 	password = 'aiiR1eX5d', #
 										host = '193.182.121.238', dbname = "kriita_survey", port = 3306),#
 										silent = TRUE)
for( i in seq_len(NROW(tmp)))#
{#
	oo		<- tmp[i, personId]#
	dbSendQuery(con, statement =  "delete  from PaylevoCreditCheck where personId = '%s'", oo)	#
}
oo
for( i in seq_len(NROW(tmp)))#
{#
	oo		<- tmp[i, personId]#
	dbSendQuery(con, statement =  sprintf("delete  from PaylevoCreditCheck where personId = '%s'", oo))	#
}
readXML			<- function(x)#
{#
#
	xml_1			<- x[, xmlParse( sourceData)]#
	.ssn			<- x[, trimws(ssn)]#
	.person			<- x[, trimws(personId)]#
	.country		<- x[, trimws(country)]#
	.checkdate		<- x[, trimws(checkDate)]#
	.sourcetype		<- x[, trimws(source)]#
	cat("\nPersonId : ", .person	 , "\n")#
	xml_2  			<- getNodeSet(xml_1, "//GETDATA_RESPONSE")[[1]]#
	xml_3 			<- xmlSApply(xml_2, xmlValue)#
	if(	length(xml_3) < 10 )#
	{#
		return( message("no values inside xml: ssn ", 	.ssn) )#
	}#
	dataDT 			<- data.table(keys	= names(xml_3), values = xml_3)#
	rmKeys			<- '(PNR|FIRST_NAME|GIVEN_NAME|LAST_NAME|CO_ADDRESS|REGISTERED_ADDRESS|ADDRESS|ZIPCODE|TOWN|COMMUNITY|FORSAMLING|FORSAMLINGNO|VAT)'#
	dataDT1			<-  dataDT[!keys %like% rmKeys, ]#
	dataDT1[values == '',  values := NA]#
	dataDT1[, ':=' ( keys 	= toupper(keys),#
						values 	= as.character(values)) ]	#
	sourceData		<-	jsonlite::toJSON( dataDT1)#
	insertPersonDB(ids = .person, country = .country, checkDate = .checkdate, sourceT = .sourcetype, sourceData = sourceData)#
	cat("************* DONE***************")	#
}
PaylevoCreditCheck	<- getData(query = "select * from kriita_survey.PaylevoCreditCheck where sourceType = 'CREDITSAFE'")
PaylevoCreditCheck[, .N, by = .(personId, checkDate)]
PaylevoCreditCheck[, .N, by = .(personId, checkDate)][ N >1]
PaylevoCreditCheck[, .N, by = .(personId)][ N >1]
PaylevoCreditCheck[personId == '27637']
selectionDT			<- merge(	PaylevoCreditCheck[, .(checkDate, personId)], #
								SsnLookupLog[, .( checkDate, personId)], by = c('checkDate', 'personId'), all.x = TRUE) #
idx					<- unique(selectionDT$personId)#
idx1				<- ErpInvoice[grepl("Delta", collectionParty), unique(personId) ]#
setkey(SsnLookupLog, personId)#
#
upDatePerson		<- SsnLookupLog[!J(idx)][J(idx1)][!is.na(checkDate), unique(personId)]#
rm(idx, idx1)#
SsnLookupLog_1		<- unique(SsnLookupLog[J(upDatePerson)], by = 'personId', fromLast = TRUE)#
Nrow				<- NROW(SsnLookupLog_1)
Nrow
logOutput		<- file.path('.', 'out.txt')#
	library(doSNOW)#
	library(doParallel)#
	Tid <- system.time({#
			 cores 	<- getOption("mc.cores", detectCores())#
			cl		<- makeCluster( cores, outfile = logOutput ) #
			clusterCall( cl, worker.init,  c('data.table', 'XML', 'RMySQL', 'jsonlite'))#
			## Används för lägga in webExtrac och data in i environmnet#
			clusterExport(cl, c("SsnLookupLog_1", "readXML","logOutput","insertPersonDB","closeConnections"), envir = environment())#
			Output	<- parLapply(cl, 1:NROW( SsnLookupLog_1 ), #
				function( x ) readXML( SsnLookupLog_1[x]) )#
			stopCluster(cl)#
		})[1:3]
PaylevoCreditCheck	<- getData(query = "select * from kriita_survey.PaylevoCreditCheck where sourceType = 'CREDITSAFE'")
selectionDT			<- merge(	PaylevoCreditCheck[, .(checkDate, personId)], #
								SsnLookupLog[, .( checkDate, personId)], by = c('checkDate', 'personId'), all.x = TRUE) #
idx					<- unique(selectionDT$personId)#
idx1				<- ErpInvoice[grepl("Delta", collectionParty), unique(personId) ]#
setkey(SsnLookupLog, personId)#
#
upDatePerson		<- SsnLookupLog[!J(idx)][J(idx1)][!is.na(checkDate), unique(personId)]
upDatePerson
length(upDatePerson)
stopifnot( length(upDatePerson) > 0)
stopifnot( length(upDatePerson) == 0)
stopifnot( length(upDatePerson) > 0)
rm(idx, idx1)
SsnLookupLog_1
stop("error")
!/usr/bin/env Rscript #
###########################################################################################
# Use for inserting person into table for credit data for api function#
###########################################################################################
library(XML)#
library(jsonlite)#
options(error = function() traceback(2))#
RFiles 					<- list.files(path = '.' , include.dirs = TRUE, pattern = "*.R$", #
											recursive = TRUE, full.names = TRUE)#
# Load common functions and files , also Meocode and Person table is loaded#
source(file = grep("commonfunction", RFiles,  value = TRUE, perl = TRUE, ignore.case = TRUE) )#
worker.init		<- function( pkg ){#
			for( p in pkg ){#
				library( p, character.only = TRUE)#
			}#
			NULL#
		}#
insertPersonDB		<- function(ids, country, checkDate, sourceT,  sourceData )#
{#
		date			<- ifelse(missing(checkDate), Sys.Date(), checkDate)#
		country			<- ifelse(missing(country), 'SE', country)#
		sourceT			<- ifelse(missing(sourceT), 'CREDITCHECK', sourceT)#
		if(missing(sourceData) || missing(ids)) stop("Script is stopped, missing source")#
		if( !  exists('con'))#
		{#
				con	 <- try( dbConnect(MySQL(),	user = 'serdara', 	password = 'aiiR1eX5d', #
 										host = '193.182.121.238', dbname = "kriita_survey", port = 3306),#
 										silent = TRUE)	#
 				if(inherits(con, 'try-error'))#
 				{#
 					closeConnections()#
 					con	 <- try( dbConnect(MySQL(),	user = 'serdara', 	password = 'aiiR1eX5d', #
 										host = '193.182.121.238', dbname = "kriita_survey", port = 3306),#
 										silent = TRUE)	#
 				}	#
 		}									#
		insertQuery		<- sprintf("INSERT INTO PaylevoCreditCheck( `personId`, `country`, `checkDate`, `sourceType`, `sourceData` ) #
											VALUES('%s','%s', '%s', '%s', '%s')",  ids , country, date , sourceT , sourceData )		#
		insertQuery 	<- gsub("[\t\n\t]", "", insertQuery)#
		res				<-  dbSendQuery(con, statement =  insertQuery)	#
		cat("###############Sucess###############", "\n")#
		dbClearResult(res)#
}		#
readXML			<- function(x)#
{#
#
	xml_1			<- x[, xmlParse( sourceData)]#
	.ssn			<- x[, trimws(ssn)]#
	.person			<- x[, trimws(personId)]#
	.country		<- x[, trimws(country)]#
	.checkdate		<- x[, trimws(checkDate)]#
	.sourcetype		<- x[, trimws(source)]#
	cat("\nPersonId : ", .person	 , "\n")#
	xml_2  			<- getNodeSet(xml_1, "//GETDATA_RESPONSE")[[1]]#
	xml_3 			<- xmlSApply(xml_2, xmlValue)#
	if(	length(xml_3) < 10 )#
	{#
		return( message("no values inside xml: ssn ", 	.ssn) )#
	}#
	dataDT 			<- data.table(keys	= names(xml_3), values = xml_3)#
	rmKeys			<- '(PNR|FIRST_NAME|GIVEN_NAME|LAST_NAME|CO_ADDRESS|REGISTERED_ADDRESS|ADDRESS|ZIPCODE|TOWN|COMMUNITY|FORSAMLING|FORSAMLINGNO|VAT)'#
	dataDT1			<-  dataDT[!keys %like% rmKeys, ]#
	dataDT1[values == '',  values := NA]#
	dataDT1[, ':=' ( keys 	= toupper(keys),#
						values 	= as.character(values)) ]	#
	sourceData		<-	jsonlite::toJSON( dataDT1)#
	insertPersonDB(ids = .person, country = .country, checkDate = .checkdate, sourceT = .sourcetype, sourceData = sourceData)#
	cat("************* DONE***************")	#
}		#
###############################################################################
# Funtion used for getting the persons#
##############################################################################			#
closeConnections 		<- function( )#
{#
	allCons 	<- 	dbListConnections(MySQL())#
	for( cons in allCons) dbDisconnect(cons)#
	con	 <- try( dbConnect(MySQL(),	user = 'serdara', 	password = 'aiiR1eX5d', #
 									host = '193.182.121.238', dbname = "kriita_survey", port = 3306),#
 									silent = TRUE)#
 	tmp	<- dbGetQuery(con, "show processlist")#
 	setDT(tmp)#
 	tmp1			<- tmp[db == 'kriita_survey' & ! grepl("processlist", Info)]#
 	if( NROW(tmp1) > 100) {#
 		for( i in 30:NROW(tmp1))#
 		{#
 			cat("\n==", i, "\n")#
 			Kill			<- paste0("KILL ", tmp1[i, Id])#
 			dbGetQuery(con, Kill)#
 		}#
 	} else {#
 		return()#
 	} #
 	dbDisconnect(con)#
}			#
######################################################################################################
# Load data #
######################################################################################################
Query 	<- sprintf("SELECT 	ei.*,#
							iv.personId,#
							iv.siteId,#
							iv.ocrNumber,#
							iv.ocrNumberReminder,#
							iv.dueDate,#
							iv.playerId,#
							ss.type,#
							ss.operatorId, #
							iv.state,#
							IF( ei.playingCurrency = 'EUR' #
									AND ei.invoiceCurrency = 'SEK', #
										ei.originalSettlementFee*ei.conversionRate, #
											ei.originalSettlementFee) AS TransactionFee#
							FROM ErpInvoice ei #
						INNER JOIN Invoice iv ON (ei.invoiceNumber = iv.invoiceNumber)#
						INNER JOIN Site ss ON (iv.siteId = ss.siteId)")#
ErpInvoice 				<- getData(query = Query )#
ErpInvoice[order(createdAt), Count := 1:.N, by = .(personId)]#
Query				<- "SELECT * FROM SsnLookupLog WHERE type = 'CREDITCHECK' AND source = 'CREDITSAFE'"#
SsnLookupLog 		<- getData(query = Query)#
SsnLookupLog 		<- merge(SsnLookupLog , Person[, .(ssn, personId)], by = 'ssn', all.x = TRUE)#
SsnLookupLog[, checkDate := as.character(as.Date(createdAt))]#
PaylevoCreditCheck	<- getData(query = "select * from kriita_survey.PaylevoCreditCheck where sourceType = 'CREDITSAFE'")#
if(FALSE){#
	tmp		<- unique(PaylevoCreditCheck[, .(ordinal, checkDate, personId)], by = 'personId', fromLast = TRUE) #
	for( i in seq_len(NROW(tmp)))#
	{#
		PaylevoCreditCheck[, .N, by = .(personId)][ N >1]#
#
		oo		<- tmp[i, personId]#
		dbSendQuery(con, statement =  sprintf("delete  from PaylevoCreditCheck where personId = '%s'", oo))	#
	}#
}#
selectionDT			<- merge(	PaylevoCreditCheck[, .(checkDate, personId)], #
								SsnLookupLog[, .( checkDate, personId)], by = c('checkDate', 'personId'), all.x = TRUE) #
idx					<- unique(selectionDT$personId)#
idx1				<- ErpInvoice[grepl("Delta", collectionParty), unique(personId) ]#
setkey(SsnLookupLog, personId)#
#
upDatePerson		<- SsnLookupLog[!J(idx)][J(idx1)][!is.na(checkDate), unique(personId)]#
if( length(upDatePerson) == 0)#
{#
	stop("error script")#
} else {#
rm(idx, idx1)#
SsnLookupLog_1		<- unique(SsnLookupLog[J(upDatePerson)], by = 'personId', fromLast = TRUE)#
Nrow				<- NROW(SsnLookupLog_1)
upDatePerson
LOG
LOGS
length(upDatePerson)
cat("Going to update ", length(upDatePerson), "persons")
file.path("../")
file.path("../logs")
dir(file.path("../logs"))
LOGS					<- file.path("../logs")
cat("Going to update ", length(upDatePerson), "persons", file = file.path(LOGS, "run.txt"), append = TRUE)
file.exists(file.path(LOGS, "run.txt"))
RUN						<- file.path(LOGS, "run.txt")
file.remove
file.remove(RUN)
file.exists(RUN) &&  file.remove(RUN)
#!/usr/bin/env Rscript #
###########################################################################################
# Use for inserting person into table for credit data for api function#
###########################################################################################
library(XML)#
library(jsonlite)#
#options(error = function() traceback(2))#
#
LOGS					<- file.path("../logs")#
RUN						<- file.path(LOGS, "run.txt")#
#
file.exists(RUN) &&  file.remove(RUN)#
RFiles 					<- list.files(path = '.' , include.dirs = TRUE, pattern = "*.R$", #
											recursive = TRUE, full.names = TRUE)#
# Load common functions and files , also Meocode and Person table is loaded#
source(file = grep("commonfunction", RFiles,  value = TRUE, perl = TRUE, ignore.case = TRUE) )#
worker.init		<- function( pkg ){#
			for( p in pkg ){#
				library( p, character.only = TRUE)#
			}#
			NULL#
		}#
args1			<- ifelse( length( commandArgs(TRUE)) > 0, commandArgs(TRUE), "survival")#
args1			<- tolower(args1)#
insertPersonDB		<- function(ids, country, checkDate, sourceT,  sourceData )#
{#
		date			<- ifelse(missing(checkDate), Sys.Date(), checkDate)#
		country			<- ifelse(missing(country), 'SE', country)#
		sourceT			<- ifelse(missing(sourceT), 'CREDITCHECK', sourceT)#
		if(missing(sourceData) || missing(ids)) stop("Script is stopped, missing source")#
		if( !  exists('con'))#
		{#
				con	 <- try( dbConnect(MySQL(),	user = 'serdara', 	password = 'aiiR1eX5d', #
 										host = '193.182.121.238', dbname = "kriita_survey", port = 3306),#
 										silent = TRUE)	#
 				if(inherits(con, 'try-error'))#
 				{#
 					closeConnections()#
 					con	 <- try( dbConnect(MySQL(),	user = 'serdara', 	password = 'aiiR1eX5d', #
 										host = '193.182.121.238', dbname = "kriita_survey", port = 3306),#
 										silent = TRUE)	#
 				}	#
 		}									#
		insertQuery		<- sprintf("INSERT INTO PaylevoCreditCheck( `personId`, `country`, `checkDate`, `sourceType`, `sourceData` ) #
											VALUES('%s','%s', '%s', '%s', '%s')",  ids , country, date , sourceT , sourceData )		#
		insertQuery 	<- gsub("[\t\n\t]", "", insertQuery)#
		res				<-  dbSendQuery(con, statement =  insertQuery)	#
		cat("###############Sucess###############", "\n")#
		dbClearResult(res)#
}		#
readXML			<- function(x)#
{#
#
	xml_1			<- x[, xmlParse( sourceData)]#
	.ssn			<- x[, trimws(ssn)]#
	.person			<- x[, trimws(personId)]#
	.country		<- x[, trimws(country)]#
	.checkdate		<- x[, trimws(checkDate)]#
	.sourcetype		<- x[, trimws(source)]#
	cat("\nPersonId : ", .person	 , "\n")#
	xml_2  			<- getNodeSet(xml_1, "//GETDATA_RESPONSE")[[1]]#
	xml_3 			<- xmlSApply(xml_2, xmlValue)#
	if(	length(xml_3) < 10 )#
	{#
		return( message("no values inside xml: ssn ", 	.ssn) )#
	}#
	dataDT 			<- data.table(keys	= names(xml_3), values = xml_3)#
	rmKeys			<- '(PNR|FIRST_NAME|GIVEN_NAME|LAST_NAME|CO_ADDRESS|REGISTERED_ADDRESS|ADDRESS|ZIPCODE|TOWN|COMMUNITY|FORSAMLING|FORSAMLINGNO|VAT)'#
	dataDT1			<-  dataDT[!keys %like% rmKeys, ]#
	dataDT1[values == '',  values := NA]#
	dataDT1[, ':=' ( keys 	= toupper(keys),#
						values 	= as.character(values)) ]	#
	sourceData		<-	jsonlite::toJSON( dataDT1)#
	insertPersonDB(ids = .person, country = .country, checkDate = .checkdate, sourceT = .sourcetype, sourceData = sourceData)#
	cat("************* DONE***************")	#
}		#
###############################################################################
# Funtion used for getting the persons#
##############################################################################			#
closeConnections 		<- function( )#
{#
	allCons 	<- 	dbListConnections(MySQL())#
	for( cons in allCons) dbDisconnect(cons)#
	con	 <- try( dbConnect(MySQL(),	user = 'serdara', 	password = 'aiiR1eX5d', #
 									host = '193.182.121.238', dbname = "kriita_survey", port = 3306),#
 									silent = TRUE)#
 	tmp	<- dbGetQuery(con, "show processlist")#
 	setDT(tmp)#
 	tmp1			<- tmp[db == 'kriita_survey' & ! grepl("processlist", Info)]#
 	if( NROW(tmp1) > 100) {#
 		for( i in 30:NROW(tmp1))#
 		{#
 			cat("\n==", i, "\n")#
 			Kill			<- paste0("KILL ", tmp1[i, Id])#
 			dbGetQuery(con, Kill)#
 		}#
 	} else {#
 		return()#
 	} #
 	dbDisconnect(con)#
}			#
######################################################################################################
# Load data #
######################################################################################################
Query 	<- sprintf("SELECT 	ei.*,#
							iv.personId,#
							iv.siteId,#
							iv.ocrNumber,#
							iv.ocrNumberReminder,#
							iv.dueDate,#
							iv.playerId,#
							ss.type,#
							ss.operatorId, #
							iv.state,#
							IF( ei.playingCurrency = 'EUR' #
									AND ei.invoiceCurrency = 'SEK', #
										ei.originalSettlementFee*ei.conversionRate, #
											ei.originalSettlementFee) AS TransactionFee#
							FROM ErpInvoice ei #
						INNER JOIN Invoice iv ON (ei.invoiceNumber = iv.invoiceNumber)#
						INNER JOIN Site ss ON (iv.siteId = ss.siteId)")#
ErpInvoice 				<- getData(query = Query )#
ErpInvoice[order(createdAt), Count := 1:.N, by = .(personId)]#
Query				<- "SELECT * FROM SsnLookupLog WHERE type = 'CREDITCHECK' AND source = 'CREDITSAFE'"#
SsnLookupLog 		<- getData(query = Query)#
SsnLookupLog 		<- merge(SsnLookupLog , Person[, .(ssn, personId)], by = 'ssn', all.x = TRUE)#
SsnLookupLog[, checkDate := as.character(as.Date(createdAt))]#
PaylevoCreditCheck	<- getData(query = "select * from kriita_survey.PaylevoCreditCheck where sourceType = 'CREDITSAFE'")
SsnLookupLog
selectionDT			<- merge(	PaylevoCreditCheck[, .(checkDate, personId)], #
								SsnLookupLog[, .( checkDate, personId)], by = c('checkDate', 'personId'), all.x = TRUE)
selectionDT
idx					<- unique(selectionDT$personId)
idx1				<- ErpInvoice[, unique(personId) ]
setkey(SsnLookupLog, personId)
upDatePerson		<- SsnLookupLog[!J(idx)][J(idx1)][!is.na(checkDate), unique(personId)]
upDatePerson
cat("Going to update ", length(upDatePerson), "persons", file = RUN , append = TRUE)
SsnLookupLog_1		<- unique(SsnLookupLog[J(upDatePerson)], by = 'personId', fromLast = TRUE)
SsnLookupLog_1
Nrow				<- NROW(SsnLookupLog_1)
Nrow				<- NROW(SsnLookupLog_1)#
if(Nrow > 100)#
{#
	logOutput		<- file.path('.', 'out.txt')#
	library(doSNOW)#
	library(doParallel)#
	Tid <- system.time({#
			 cores 	<- getOption("mc.cores", detectCores())#
			cl		<- makeCluster( cores, outfile = logOutput ) #
			clusterCall( cl, worker.init,  c('data.table', 'XML', 'RMySQL', 'jsonlite'))#
			## Används för lägga in webExtrac och data in i environmnet#
			clusterExport(cl, c("SsnLookupLog_1", "readXML","logOutput","insertPersonDB","closeConnections"), envir = environment())#
			Output	<- parLapply(cl, 1:NROW( SsnLookupLog_1 ), #
				function( x ) readXML( SsnLookupLog_1[x]) )#
			stopCluster(cl)#
		})[1:3]#
} else {#
	for( x in seq_len(Nrow))#
	{#
		cat(x, "\n")#
		readXML( SsnLookupLog_1[x] )#
	}#
}
SsnLookupLog_1
SsnLookupLog_1[personId == '42006']
SsnLookupLog_1[which(personId =='42006')]
PaylevoCreditCheck	<- getData(query = "select * from kriita_survey.PaylevoCreditCheck where sourceType = 'CREDITSAFE'")
PaylevoCreditCheck[personId == '42006']
selectionDT			<- merge(	PaylevoCreditCheck[, .(checkDate, personId)], #
								SsnLookupLog[, .( checkDate, personId)], by = c('checkDate', 'personId'), all.x = TRUE) #
idx					<- unique(selectionDT$personId)#
idx1				<- ErpInvoice[, unique(personId) ]#
setkey(SsnLookupLog, personId)#
#
upDatePerson		<- SsnLookupLog[!J(idx)][J(idx1)][!is.na(checkDate), unique(personId)]#
if( length(upDatePerson) == 0)#
{#
	stop("error script")#
} else {#
rm(idx, idx1)#
cat("Going to update ", length(upDatePerson), "persons", file = RUN , append = TRUE)#
SsnLookupLog_1		<- unique(SsnLookupLog[J(upDatePerson)], by = 'personId', fromLast = TRUE)#
Nrow				<- NROW(SsnLookupLog_1)
selectionDT			<- merge(	PaylevoCreditCheck[, .(checkDate, personId)], #
								SsnLookupLog[, .( checkDate, personId)], by = c('checkDate', 'personId'), all.x = TRUE) #
idx					<- unique(selectionDT$personId)#
idx1				<- ErpInvoice[, unique(personId) ]#
setkey(SsnLookupLog, personId)
upDatePerson		<- SsnLookupLog[!J(idx)][J(idx1)][!is.na(checkDate), unique(personId)]
upDatePerson
rm(idx, idx1)
cat("Going to update ", length(upDatePerson), "persons", file = RUN , append = TRUE)
length(upDatePerson)
SsnLookupLog_1		<- unique(SsnLookupLog[J(upDatePerson)], by = 'personId', fromLast = TRUE)
Nrow				<- NROW(SsnLookupLog_1)
Nrow
logOutput		<- file.path('.', 'out.txt')#
	library(doSNOW)#
	library(doParallel)#
	Tid <- system.time({#
			 cores 	<- getOption("mc.cores", detectCores())#
			cl		<- makeCluster( cores, outfile = logOutput ) #
			clusterCall( cl, worker.init,  c('data.table', 'XML', 'RMySQL', 'jsonlite'))#
			## Används för lägga in webExtrac och data in i environmnet#
			clusterExport(cl, c("SsnLookupLog_1", "readXML","logOutput","insertPersonDB","closeConnections"), envir = environment())#
			Output	<- parLapply(cl, 1:NROW( SsnLookupLog_1 ), #
				function( x ) readXML( SsnLookupLog_1[x]) )#
			stopCluster(cl)
})[1:3]
PaylevoCreditCheck	<- getData(query = "select * from kriita_survey.PaylevoCreditCheck where sourceType = 'CREDITSAFE'")
selectionDT			<- merge(	PaylevoCreditCheck[, .(checkDate, personId)], #
								SsnLookupLog[, .( checkDate, personId)], by = c('checkDate', 'personId'), all.x = TRUE) #
idx					<- unique(selectionDT$personId)#
idx1				<- ErpInvoice[, unique(personId) ]#
setkey(SsnLookupLog, personId)#
#
upDatePerson		<- SsnLookupLog[!J(idx)][J(idx1)][!is.na(checkDate), unique(personId)]#
if( length(upDatePerson) == 0)#
{#
	stop("error script")#
} else {#
rm(idx, idx1)#
cat("Going to update ", length(upDatePerson), "persons", file = RUN , append = TRUE)#
SsnLookupLog_1		<- unique(SsnLookupLog[J(upDatePerson)], by = 'personId', fromLast = TRUE)#
Nrow				<- NROW(SsnLookupLog_1)
selectionDT			<- merge(	PaylevoCreditCheck[, .(checkDate, personId)], #
								SsnLookupLog[, .( checkDate, personId)], by = c('checkDate', 'personId'), all.x = TRUE) #
idx					<- unique(selectionDT$personId)#
idx1				<- ErpInvoice[, unique(personId) ]#
setkey(SsnLookupLog, personId)#
#
upDatePerson		<- SsnLookupLog[!J(idx)][J(idx1)][!is.na(checkDate), unique(personId)]
cat("Going to update ", length(upDatePerson), "persons", file = RUN , append = TRUE)#
SsnLookupLog_1		<- unique(SsnLookupLog[J(upDatePerson)], by = 'personId', fromLast = TRUE)#
Nrow				<- NROW(SsnLookupLog_1)
Nrow
logOutput		<- file.path('.', 'out.txt')#
	library(doSNOW)#
	library(doParallel)#
	Tid <- system.time({#
			 cores 	<- getOption("mc.cores", detectCores())#
			cl		<- makeCluster( cores, outfile = logOutput ) #
			clusterCall( cl, worker.init,  c('data.table', 'XML', 'RMySQL', 'jsonlite'))#
			## Används för lägga in webExtrac och data in i environmnet#
			clusterExport(cl, c("SsnLookupLog_1", "readXML","logOutput","insertPersonDB","closeConnections"), envir = environment())#
			Output	<- parLapply(cl, 1:NROW( SsnLookupLog_1 ), #
				function( x ) readXML( SsnLookupLog_1[x]) )#
			stopCluster(cl)#
		})[1:3]
PaylevoCreditCheck	<- getData(query = "select * from kriita_survey.PaylevoCreditCheck where sourceType = 'CREDITSAFE'")
stopCluster(cl)
PaylevoCreditCheck	<- getData(query = "select * from kriita_survey.PaylevoCreditCheck where sourceType = 'CREDITSAFE'")
selectionDT			<- merge(	PaylevoCreditCheck[, .(checkDate, personId)], #
								SsnLookupLog[, .( checkDate, personId)], by = c('checkDate', 'personId'), all.x = TRUE) #
idx					<- unique(selectionDT$personId)#
idx1				<- ErpInvoice[, unique(personId) ]#
setkey(SsnLookupLog, personId)#
#
upDatePerson		<- SsnLookupLog[!J(idx)][J(idx1)][!is.na(checkDate), unique(personId)]
cat("Going to update ", length(upDatePerson), "persons", file = RUN , append = TRUE)#
SsnLookupLog_1		<- unique(SsnLookupLog[J(upDatePerson)], by = 'personId', fromLast = TRUE)#
Nrow				<- NROW(SsnLookupLog_1)
Nrow
for( x in seq_len(Nrow))#
	{#
		cat(x, "\n")#
		readXML( SsnLookupLog_1[x] )#
	}
SsnLookupLog_1
SsnLookupLog_1[personId == '55399']
readXML( SsnLookupLog_1[personId == '55399'] )
x
SsnLookupLog_1[144]
SsnLookupLog_1[145]
SsnLookupLog_1[146]
seq_len(Nrow)
for( x in 146:Nrow)#
	{#
		cat(x, "\n")#
		readXML( SsnLookupLog_1[x] )#
	}
SsnLookupLog_1[personId == '1157']
x
PaylevoCreditCheck	<- getData(query = "select * from kriita_survey.PaylevoCreditCheck where sourceType = 'CREDITSAFE'")
selectionDT			<- merge(	PaylevoCreditCheck[, .(checkDate, personId)], #
								SsnLookupLog[, .( checkDate, personId)], by = c('checkDate', 'personId'), all.x = TRUE) #
idx					<- unique(selectionDT$personId)#
idx1				<- ErpInvoice[, unique(personId) ]#
setkey(SsnLookupLog, personId)#
#
upDatePerson		<- SsnLookupLog[!J(idx)][J(idx1)][!is.na(checkDate), unique(personId)]
cat("Going to update ", length(upDatePerson), "persons", file = RUN , append = TRUE)#
SsnLookupLog_1		<- unique(SsnLookupLog[J(upDatePerson)], by = 'personId', fromLast = TRUE)#
Nrow				<- NROW(SsnLookupLog_1)
Nrow
PaylevoCreditCheck
PaylevoCreditCheck[, .N, by = .(personId)]
PaylevoCreditCheck[, .N, by = .(personId)][N > 1]
PaylevoCreditCheck[personId == '22984']
#!/usr/bin/env Rscript #
###########################################################################################
# Use for inserting person into table for credit data for api function#
###########################################################################################
library(XML)#
library(jsonlite)#
#options(error = function() traceback(2))#
#
LOGS					<- file.path("../logs")#
RUN						<- file.path(LOGS, "run.txt")#
#
file.exists(RUN) &&  file.remove(RUN)#
RFiles 					<- list.files(path = '.' , include.dirs = TRUE, pattern = "*.R$", #
											recursive = TRUE, full.names = TRUE)#
# Load common functions and files , also Meocode and Person table is loaded#
source(file = grep("commonfunction", RFiles,  value = TRUE, perl = TRUE, ignore.case = TRUE) )#
worker.init		<- function( pkg ){#
			for( p in pkg ){#
				library( p, character.only = TRUE)#
			}#
			NULL#
		}#
args1			<- ifelse( length( commandArgs(TRUE)) > 0, commandArgs(TRUE), "survival")#
args1			<- tolower(args1)#
insertPersonDB		<- function(ids, country, checkDate, sourceT,  sourceData )#
{#
		date			<- ifelse(missing(checkDate), Sys.Date(), checkDate)#
		country			<- ifelse(missing(country), 'SE', country)#
		sourceT			<- ifelse(missing(sourceT), 'CREDITCHECK', sourceT)#
		if(missing(sourceData) || missing(ids)) stop("Script is stopped, missing source")#
		if( !  exists('con'))#
		{#
				con	 <- try( dbConnect(MySQL(),	user = 'serdara', 	password = 'aiiR1eX5d', #
 										host = '193.182.121.238', dbname = "kriita_survey", port = 3306),#
 										silent = TRUE)	#
 				if(inherits(con, 'try-error'))#
 				{#
 					closeConnections()#
 					con	 <- try( dbConnect(MySQL(),	user = 'serdara', 	password = 'aiiR1eX5d', #
 										host = '193.182.121.238', dbname = "kriita_survey", port = 3306),#
 										silent = TRUE)	#
 				}	#
 		}									#
		insertQuery		<- sprintf("INSERT INTO PaylevoCreditCheck( `personId`, `country`, `checkDate`, `sourceType`, `sourceData` ) #
											VALUES('%s','%s', '%s', '%s', '%s')",  ids , country, date , sourceT , sourceData )		#
		insertQuery 	<- gsub("[\t\n\t]", "", insertQuery)#
		res				<-  dbSendQuery(con, statement =  insertQuery)	#
		cat("###############Sucess###############", "\n")#
		dbClearResult(res)#
}		#
readXML			<- function(x)#
{#
#
	xml_1			<- x[, xmlParse( sourceData)]#
	.ssn			<- x[, trimws(ssn)]#
	.person			<- x[, trimws(personId)]#
	.country		<- x[, trimws(country)]#
	.checkdate		<- x[, trimws(checkDate)]#
	.sourcetype		<- x[, trimws(source)]#
	cat("\nPersonId : ", .person	 , "\n")#
	xml_2  			<- getNodeSet(xml_1, "//GETDATA_RESPONSE")[[1]]#
	xml_3 			<- xmlSApply(xml_2, xmlValue)#
	if(	length(xml_3) < 10 )#
	{#
		return( message("no values inside xml: ssn ", 	.ssn) )#
	}#
	dataDT 			<- data.table(keys	= names(xml_3), values = xml_3)#
	rmKeys			<- '(PNR|FIRST_NAME|GIVEN_NAME|LAST_NAME|CO_ADDRESS|REGISTERED_ADDRESS|ADDRESS|ZIPCODE|TOWN|COMMUNITY|FORSAMLING|FORSAMLINGNO|VAT)'#
	dataDT1			<-  dataDT[!keys %like% rmKeys, ]#
	dataDT1[values == '',  values := NA]#
	dataDT1[, ':=' ( keys 	= toupper(keys),#
						values 	= as.character(values)) ]	#
	sourceData		<-	jsonlite::toJSON( dataDT1)#
	insertPersonDB(ids = .person, country = .country, checkDate = .checkdate, sourceT = .sourcetype, sourceData = sourceData)#
	cat("************* DONE***************")	#
}		#
###############################################################################
# Funtion used for getting the persons#
##############################################################################			#
closeConnections 		<- function( )#
{#
	allCons 	<- 	dbListConnections(MySQL())#
	for( cons in allCons) dbDisconnect(cons)#
	con	 <- try( dbConnect(MySQL(),	user = 'serdara', 	password = 'aiiR1eX5d', #
 									host = '193.182.121.238', dbname = "kriita_survey", port = 3306),#
 									silent = TRUE)#
 	tmp	<- dbGetQuery(con, "show processlist")#
 	setDT(tmp)#
 	tmp1			<- tmp[db == 'kriita_survey' & ! grepl("processlist", Info)]#
 	if( NROW(tmp1) > 100) {#
 		for( i in 30:NROW(tmp1))#
 		{#
 			cat("\n==", i, "\n")#
 			Kill			<- paste0("KILL ", tmp1[i, Id])#
 			dbGetQuery(con, Kill)#
 		}#
 	} else {#
 		return()#
 	} #
 	dbDisconnect(con)#
}			#
######################################################################################################
# Load data #
######################################################################################################
Query 	<- sprintf("SELECT 	ei.*,#
							iv.personId,#
							iv.siteId,#
							iv.ocrNumber,#
							iv.ocrNumberReminder,#
							iv.dueDate,#
							iv.playerId,#
							ss.type,#
							ss.operatorId, #
							iv.state,#
							IF( ei.playingCurrency = 'EUR' #
									AND ei.invoiceCurrency = 'SEK', #
										ei.originalSettlementFee*ei.conversionRate, #
											ei.originalSettlementFee) AS TransactionFee#
							FROM ErpInvoice ei #
						INNER JOIN Invoice iv ON (ei.invoiceNumber = iv.invoiceNumber)#
						INNER JOIN Site ss ON (iv.siteId = ss.siteId)")#
ErpInvoice 				<- getData(query = Query )#
ErpInvoice[order(createdAt), Count := 1:.N, by = .(personId)]#
Query				<- "SELECT * FROM SsnLookupLog WHERE type = 'CREDITCHECK' AND source = 'CREDITSAFE'"#
SsnLookupLog 		<- getData(query = Query)#
SsnLookupLog 		<- merge(SsnLookupLog , Person[, .(ssn, personId)], by = 'ssn', all.x = TRUE)#
SsnLookupLog[, checkDate := as.character(as.Date(createdAt))]#
PaylevoCreditCheck	<- getData(query = "select * from kriita_survey.PaylevoCreditCheck where sourceType = 'CREDITSAFE'")#
if(FALSE){#
	tmp		<- unique(PaylevoCreditCheck[, .(ordinal, checkDate, personId)], by = 'personId', fromLast = TRUE) #
	for( i in seq_len(NROW(tmp)))#
	{#
		PaylevoCreditCheck[, .N, by = .(personId)][ N >1]#
#
		oo		<- tmp[i, personId]#
		dbSendQuery(con, statement =  sprintf("delete  from PaylevoCreditCheck where personId = '%s'", oo))	#
	}#
}#
#
selectionDT			<- merge(	PaylevoCreditCheck[, .(checkDate, personId)], #
								SsnLookupLog[, .( checkDate, personId)], by = c('checkDate', 'personId'), all.x = TRUE) #
idx					<- unique(selectionDT$personId)#
idx1				<- ErpInvoice[, unique(personId) ]#
setkey(SsnLookupLog, personId)#
#
upDatePerson		<- SsnLookupLog[!J(idx)][J(idx1)][!is.na(checkDate), unique(personId)]
upDatePerson
length(upDatePerson) == 0
SsnLookupLog
if( length(upDatePerson) == 0)#
{#
	stop("error script")#
} else {#
rm(idx, idx1)#
cat("Going to update ", length(upDatePerson), "persons", file = RUN , append = TRUE)#
SsnLookupLog_1		<- unique(SsnLookupLog[J(upDatePerson)], by = 'personId', fromLast = TRUE)#
Nrow				<- NROW(SsnLookupLog_1)#
if(Nrow > 100)#
{#
	logOutput		<- file.path('.', 'out.txt')#
	library(doSNOW)#
	library(doParallel)#
	Tid <- system.time({#
			 cores 	<- getOption("mc.cores", detectCores())#
			cl		<- makeCluster( cores, outfile = logOutput ) #
			clusterCall( cl, worker.init,  c('data.table', 'XML', 'RMySQL', 'jsonlite'))#
			## Används för lägga in webExtrac och data in i environmnet#
			clusterExport(cl, c("SsnLookupLog_1", "readXML","logOutput","insertPersonDB","closeConnections"), envir = environment())#
			Output	<- parLapply(cl, 1:NROW( SsnLookupLog_1 ), #
				function( x ) readXML( SsnLookupLog_1[x]) )#
			stopCluster(cl)#
		})[1:3]#
} else {#
	for( x in 146:Nrow)#
	{#
		cat(x, "\n")#
		readXML( SsnLookupLog_1[x] )#
	}#
}	#
} ## ifelse
PaylevoCreditCheck	<- getData(query = "select * from kriita_survey.PaylevoCreditCheck where sourceType = 'CREDITSAFE'")
selectionDT			<- merge(	PaylevoCreditCheck[, .(checkDate, personId)], #
								SsnLookupLog[, .( checkDate, personId)], by = c('checkDate', 'personId'), all.x = TRUE) #
idx					<- unique(selectionDT$personId)#
idx1				<- ErpInvoice[, unique(personId) ]#
setkey(SsnLookupLog, personId)
upDatePerson		<- SsnLookupLog[!J(idx)][J(idx1)][!is.na(checkDate), unique(personId)]
upDatePerson
